<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Integer Instructions - Part 1: Introduction to Low-level Programming in C and Arm AArch64 Assembly</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="tool_installation.html"><strong aria-hidden="true">2.</strong> Tool Installation</a></li><li class="chapter-item expanded "><a href="comp_overview.html"><strong aria-hidden="true">3.</strong> Computer System Overview</a></li><li class="chapter-item expanded "><a href="arm_exec_state.html"><strong aria-hidden="true">4.</strong> ARM Registers and Execution State</a></li><li class="chapter-item expanded "><a href="binary_representation.html"><strong aria-hidden="true">5.</strong> Binary Representation of Integers</a></li><li class="chapter-item expanded "><a href="starting_assembly.html"><strong aria-hidden="true">6.</strong> ARM AArch64 Assembly Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="memory_inst.html"><strong aria-hidden="true">6.1.</strong> Memory Instructions</a></li><li class="chapter-item expanded "><a href="integer_inst.html" class="active"><strong aria-hidden="true">6.2.</strong> Integer Instructions</a></li></ol></li><li class="chapter-item expanded "><a href="condition_flags.html"><strong aria-hidden="true">7.</strong> Condition Flags</a></li><li class="chapter-item expanded "><a href="stack.html"><strong aria-hidden="true">8.</strong> The Stack</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">9.</strong> Functions</a></li><li class="chapter-item expanded "><a href="c_programming.html"><strong aria-hidden="true">10.</strong> Programming in C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="c_variables.html"><strong aria-hidden="true">10.1.</strong> Variables and Data types</a></li><li class="chapter-item expanded "><a href="c_syntax.html"><strong aria-hidden="true">10.2.</strong> C Language Syntax</a></li><li class="chapter-item expanded "><a href="c_exercises.html"><strong aria-hidden="true">10.3.</strong> C Programming Exercises</a></li><li class="chapter-item expanded "><a href="c_pointers.html"><strong aria-hidden="true">10.4.</strong> Introduction to Arrays and Pointers in C</a></li></ol></li><li class="chapter-item expanded "><a href="c2assembly.html"><strong aria-hidden="true">11.</strong> From C Programs to Assembly Code</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="disassembly.html"><strong aria-hidden="true">11.1.</strong> Disassembly examples</a></li></ol></li><li class="chapter-item expanded "><a href="conclusion_part1.html"><strong aria-hidden="true">12.</strong> Conclusion</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">13.</strong> References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Part 1: Introduction to Low-level Programming in C and Arm AArch64 Assembly</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="integer-instructions"><a class="header" href="#integer-instructions">Integer Instructions</a></h1>
<p>We have already used two arithmetic instructions - <strong>add</strong> and <strong>cmp</strong> - in the previous section. In this section we introduce a few more commonly used integer instructions. Like earlier, we will do this through a series of assembly programs. For some of the programs we have provided the explanation in pseudo code only. This is an opportunity for you to write the assembly program by yourself.</p>
<h2 id="sum-of-numbers-in-an-array"><a class="header" href="#sum-of-numbers-in-an-array">Sum of numbers in an array</a></h2>
<p>In this exercise we will add a set of numbers in a loop. We will also learn a new memory addressing method in the bargain.</p>
<p>In computer programming, arrays are data structures that consist of the same type of data stored in contiguous locations of memory. Examples of the type of data includes 8-bit integers, 16-bit integers, 32-bit integers etc. ASCII strings are arrays of 8-bit integers that have a special value that indicates the end of string. Arrays of other types do not have any end markers like strings. Therefore, the programmer should know the number of elements stored in the array so that they do not overshoot the array and access memory locations outside of it.</p>
<p><img src="images/array.png" alt="Array in memory" title="Array in memory" /></p>
<p>The figure above shows how the elements of an array appear in memory. In this example, each element is 4 bytes large. The start address of the array is in x4. Since the array elements are 4-bytes large, the address of the second element is [x4 + 4] and the one after that [x4 + 8] and so on. This array has N+1 elements and the address of the last element is [x4 + N]. Here N is just an example to show arrays can be of any length.</p>
<p>Arrays are a convenient way to store a list of the same type of object. When an operation is to be performed on all elements of a array it is typically done in a loop. Programmers can easily read/write to each item in the list by using the register + offset, pre-indexed, or post-indexed modes of addressing.</p>
<p>One common programming error is to access beyond the end of an array. The dotted region in the figure represents memory that is outside the array. Programmer should be careful to only access memory locations that are part of the program. Accessing memory outside the locations representing the program's data may not cause the program to crash always. But may cause subtle errors and crashes that are difficult to debug.</p>
<p>We will now look at a program that has 32-bit integers stored in an array. The program will add all the integers in the array and print their sum. Our program is organized as follows:</p>
<ul>
<li>The address of the first element of the array is stored in the register x4</li>
<li>The register w1 stores the number of elements in the array</li>
<li>The sum of the elements is stored in w0</li>
</ul>
<p>The address of the first element of the array is stored in the register x4. We will use the register x2 as the index for different values of the array. The relevant portion of the program is given below. The reader can try it out by typing this code in the file integer_instructions/sum.s</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make sum.elf
RUN_COMMAND: make run
</code></pre>
<p>The program code:</p>
<pre><code class="language-armasm">   // Your code starts here
    mov    x4, x0

   // Initialize sum to 0.
    mov    w0, 0

   // Iterate over elements of the array and add the value to result

   // Initialize index to 0. This register will hold the value of current element number
   mov    x2, 0
loop:
    // Load the value at current index
    ldr    w3, [x4, x2, lsl 2]

    // Add the value to sum
    add    w0, w0, w3

    // Increment the index
    add    x2, x2, 1

    // Check if we have iterated through all the elements of the array
    cmp    w1, w2

    // Branch back to beginning of loop if there are more elements
    bgt    loop

    // Your code ends here
</code></pre>
<p>One can add comments in the code by starting the line with the text &quot;//&quot;. Everything following in that line will be ignored when the program is assembled/compiled. In this program the explanation for every instruction is provided as comments. The load instruction in this program uses a slightly different form of memory addressing than the ones we have encountered so far. This addressing mode is the register + offset mode that we learnt in the section on Memory Instructions. The addressing mode allows the programmer to provide an optional operation that is to be performed on the offset register.</p>
<blockquote>
<p>ldr    w3, [x4, x2, lsl 2]</p>
</blockquote>
<p>To compute the address of the load, the offset register (x2) is left shifted by 2 and added to the x4 register.</p>
<blockquote>
<p>x4 + (x2 &lt;&lt; 2)</p>
</blockquote>
<p>Why do we left shift by 2? Every element in this array is 4 bytes large. The address of each element is offset from the base by the element's index number times 4. For example, for the 4th element in the array the offset from the begining of the array is 3 * 4 = 12 bytes. Remember that the first element of the array is at the 0th index and the fourth element is at index 3.</p>
<p>We track the index of the current element in register w2 and therefore we multiply that number by 4 to get the memory address offset. As we saw in the binary arithmetic section, multiplying by 4 is the same as left shifting by 2.</p>
<hr />
<p><strong>Extend operators in register+offset addressing:</strong></p>
<p>We used the LSL extend operator in this example. The register+offset addressing method has three other extend operators. These are:</p>
<ul>
<li>UXTW</li>
<li>SXTW</li>
<li>SXTX</li>
</ul>
<p>We will learn about these operators later in the book.</p>
<hr />
<h2 id="finding-the-maximum-number-in-an-array"><a class="header" href="#finding-the-maximum-number-in-an-array">Finding the maximum number in an array</a></h2>
<p>Here is a challenge for you. Write a program to find the maximum number in a given array of numbers. The file <em>exercises/integer_instructions/find_max.s</em> has the data set up and comments indicating where your code should be placed. Here is the information you need to write this program:</p>
<ul>
<li>The address of the first element in the array is stored in x0</li>
<li>The number of elements is in the array is in x1</li>
<li>The size of each element in the array is 1 word (4 bytes)</li>
<li>Store the number</li>
</ul>
<p>Can you write a program to find the maximum number in the array?</p>
<p>The assembly program can be written in multiple ways. It does not matter if your program is not identical to the solution as long as it finds the correct answer.</p>
<p><strong>csel</strong> is a new instruction that can be used as part of this exercise. This instruction checks the condition set by the previous instruction (could be a cmp instruction) and if the condition is true it copies the value of Wn to Wd. If the condition is false it copies the value in Wm to Wd.</p>
<pre><code class="language-armasm"> csel &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, &lt;cond&gt;
</code></pre>
<p>The condition in the cond field can be one of the following (from <a href="https://developer.arm.com/documentation/ddi0487/ga">ARM ARM</a> C.1.2.4 Condition Code) :</p>
<table><thead><tr><th>Mnemonic</th><th>Meaning (integer)</th><th>Condition Flags</th></tr></thead><tbody>
<tr><td>eq</td><td>Equal</td><td>Z == 1</td></tr>
<tr><td>ne</td><td>Not Equal</td><td>Z == 0</td></tr>
<tr><td>cs or hs</td><td>Carry Set</td><td>C == 1</td></tr>
<tr><td>cc or lo</td><td>Carry clear</td><td>C == 0</td></tr>
<tr><td>mi</td><td>Minus, negative</td><td>N == 1</td></tr>
<tr><td>pl</td><td>Plus, positive or zero</td><td>N == 0</td></tr>
<tr><td>vs</td><td>Overflow</td><td>V == 1</td></tr>
<tr><td>vc</td><td>No Overflow</td><td>V == 0</td></tr>
<tr><td>hi</td><td>Unsigned higher</td><td>C == 1 &amp;&amp; Z == 0</td></tr>
<tr><td>ls</td><td>Unsigned lower or same</td><td>!(C == 1 &amp;&amp; Z == 0)</td></tr>
<tr><td>ge</td><td>Signed greater than or equal</td><td>N == V</td></tr>
<tr><td>lt</td><td>Signed less than</td><td>N != V</td></tr>
<tr><td>gt</td><td>Signed greater than</td><td>Z == 0 &amp;&amp; N == V</td></tr>
<tr><td>le</td><td>Signed lessthan or equal</td><td>!(Z == 0 &amp;&amp; N == V)</td></tr>
</tbody></table>
<p>For example, the following instruction compares the values in 20 and w3 and copies the value in w3 to w0 if the condition specified is satisfied</p>
<blockquote>
<p>csel w0, w0, w3, ge</p>
</blockquote>
<p>If the value in w3 is greater than that in w0 then contents of w3 are copied to w0.</p>
<p>You can use the csel instruction in your program if you choose to. A solution without the instruction is also perfectly fine. Once you are done you can take a look at the code below (or in <em>exercises/integer_instructions/find_max_solution.s</em>).</p>
<details>
  <summary>Click to see the solution after you solve the problem</summary>
<pre><code class="language-armasm">    // Your code starts here
    mov    x4, x0

    // Initialize current maximum value with first element of array
    ldr    w0, [x0]

    // Check if there is only one element in the array
    cmp    w1, 1

    // Branch to done label if there is only one element
    beq    done

    // Set index to element 1
    mov    x2, 1

    // Iterate over array elements from index 2 and with current max
loop:
    ldr    w3, [x4, x2, lsl 2]

    // Compare the value against current maximum
    cmp    w0, w3

    // Select the new value if it is greater than current maximum
    csel    w0, w0, w3, ge

    // Increment the index
    add    x2, x2, 1

    // Check if we have iterated through all the elements of the array
    cmp    w1, w2

    // Branch back to beginning of loop if there are more elements
    bgt    loop
done:
    // Your code ends here
</code></pre>
</details>
<h2 id="counting-leading-zeroes"><a class="header" href="#counting-leading-zeroes">Counting leading zeroes</a></h2>
<p>In this exercise we will count the leading number of zeros in a given number. Leading zeroes are those that occur before the first 1 is encountered in the number when reading it left to right. For example, the number 0010_1011 has two leading zeroes.</p>
<p>For this exercise use the file <em>exercises/integer_instructions/clz.s</em>. We also introduce two new instructions - tbz and tbnz. In clz.s we have placed the number -  for which leading zeroes have to be found - in register w0. We will count the number of leading 0s in the given number and place the result in w0. The print function that is called later (already included in clz.s, you do not need to add it) will print the value stored in w0.</p>
<p>The code to find the number of leading zeroes is below. Try typing it out into the file and getting it working.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make clz.elf
RUN_COMMAND: make run
</code></pre>
<pre><code class="language-armasm">    // Your code starts here
    mov    w1, w0 //copy the number to w1

    // Initialize count to 0; we will use w0
    mov    w0, 0

    // Test if bit 31 of value is 1. If it is 1, branch to label 'done'
    tbnz    w1, #31, done

    // Keep left shifting the value by one until leftmost bit does not become 1
loop:
    // Left shift the value by 1
    lsl    w1, w1, 1

    // Increment the count by 1
    add    w0, w0, 1

    // Test if bit 31 is 1. If it is not 1, branch back to label 'loop'
    tbz    w1, #31, loop
done:
    // Your code ends here
</code></pre>
<p>The comments in the program should give enough information about how the code works. But there are a few new instructions that we will will go over.</p>
<p>Most of the instructions in the program should be familiar by now except <strong>tbz</strong>, <strong>tbnz</strong> and <strong>lsl</strong>. The <strong>lsl</strong> instruction takes three arguments, the destination register, the source register and a shift value. The instruction shifts the source register left by the specified amount and stores the result into the desination.</p>
<blockquote>
<p>lsl w1, w1, 1</p>
</blockquote>
<p>The above instruction shifts the value in w1 left by 1 and saves the result in w1. There is a variant of <strong>lsl</strong> where the shift value can be specified in a register. You will find the syntax for the instruction in ARM ARM.</p>
<p>The tbnz is a branch instruction that tests if the specified <strong>bit</strong>  in a given register is <strong>not zero</strong>. If the test result is true it branches to the label provided by the user. The <strong>tbz</strong> instruction checks if the bit is zero. If true it branches to the specified label.</p>
<h2 id="computing-the-factorial-of-a-number"><a class="header" href="#computing-the-factorial-of-a-number">Computing the Factorial of a number</a></h2>
<p>In this exercise we will compute the factorial of a number. Factorial value of a number 'N' is multiplication of all integers smaller than or equal to 'N'.</p>
<p>Mathematically it is written as:</p>
<pre><code>n! = 1 * 2 * 3 * 4 * ... * (n-1) * n
</code></pre>
<p>For example, factorial of 5 is:</p>
<pre><code>5 * 4 * 3 * 2 * 1 = 120
</code></pre>
<p>For this exercise use the file <em>exercises/integer_instructions/facorial.s</em>. In factorial.s we have placed - the number for which factorial will have to be computed - in register w0. We will compute the factorial and place the result in w0. The print function that is called later will print the value stored in w0.</p>
<p>We will first introduce the multiply instructions. There are multiply instructions that operate on 32-bit or 64-bit values and return a result of the same size as the operands. For example, two 64-bit registers can be multiplied to produce a 64-bit result with the MUL instruction.</p>
<pre><code>MUL &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;  // 32-bit variant
MUL &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;  // 64-bit variant
</code></pre>
<p>These instructions multiply the values in Wn(or Xn) and Wm(or Xm) and places the result in Wd(or Xd)</p>
<p>For example:</p>
<pre><code>MUL W0, W1, W2 // W0 = W1 * W2
</code></pre>
<p>Additionally, there are also multiply instructions that produce a long result, that is, multiplying two 32-bit numbers and generating a 64-bit result. There are both signed and unsigned variants of these long multiplies (UMULL, SMULL).</p>
<pre><code>UMULL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;  // Unsigned multiply long
SMULL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;  // Signed multiply long
</code></pre>
<p>Below is pseudo code to compute the factorial. You can use this as a guide to write the assembly code.</p>
<ol>
<li>Use one register (say w0) to store the computed factorial(product) and initialize it with 1</li>
<li>Use one register (say w1) to increment the values from 2 to N-1 using a loop</li>
<li>Multiply current number in w1 with the product in w0 in each iteration of the loop</li>
</ol>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make factorial.elf
RUN_COMMAND: make run
</code></pre>
<details>
  <summary>The solution to this exercise is below (also in exercises/integer_instructions/factorial_solution.s)</summary>
<pre><code class="language-armasm">    // Your code starts here
    add    w2, w0, 1

    // Initialize w0 to 1.
    mov    w0, 1

    // Initialize w0 to 2.
    mov    w1, 2

    // Multiply numbers from 2 to N-1 with w0 using a loop
loop:
    // Multiply current number in w1 with the product in w0
    mul    w0, w0, w1

    // Increment the value in w1 by 1
    add    w1, w1, 1

    // Compare w1 and w2 to check if they are equal
    cmp    w2, w1

    // Branch back to label 'loop' if w1 is not equal to w2
    bne    loop

    // Your code ends here
</code></pre>
</details>
<h2 id="matrix-subtraction-and-addition"><a class="header" href="#matrix-subtraction-and-addition">Matrix subtraction and addition</a></h2>
<p>An array of arrays is known as two dimensional (2D) array or matrix. A matrix can be represented as a table of rows and columns. Data in 2D arrays are stored in tabular form. Elements in two-dimensional arrays are commonly referred to by a[i][j] where 'i' is the row number and 'j' is the column number and 'a' is the 2D array.</p>
<p>A two dimensional array can be seen as a table with 'M' rows and 'N' columns where the row number ranges from 0 to (M-1) and column number ranges from 0 to (N-1). A two dimensional array 'a' with 4 rows and 3 columns is shown below:</p>
<p><img src="images/matrix.png" alt="Matrix" title="Matrix" /></p>
<p>A matrix of 'M' rows and 'N' rows will have 'M * N' elements.  If a matrix has same number of rows and columns, then it is called as 'square' matrix.</p>
<p>The actual representation of this matrix in memory would be something like this:</p>
<p><img src="images/matrix_representation.png" alt="Matrix in memory" title="Matrix in memory" /></p>
<p>In this exercise, we will take two square matrices, 'A' and 'B' as input parameters and store the result in matrix 'C'. Two matrices can be added only if they have the same dimensions. The result will be a matrix of the same dimensions. To perform the addition, numbers in matching postions in the input matrices are added and the result is placed in the same position in the output matrix. Following diagram illustrates this by adding two 2x2 matrices 'A' and 'B' and places the result in matrix 'C'.</p>
<p><img src="images/matrix_add.png" alt="Matrix Addition" title="Matrix Addition" /></p>
<p>For this exercise use the file exercises/integer_instructions/matrix_addition.s. In matrix_addition.s, the program registers are initialized as follows:</p>
<ol>
<li>The start address of first square matrix to be added is in register x0</li>
<li>The start address of second square matrix to be added is in register x1</li>
<li>The start address of square matrix where the sum of matrix A and matrix B needs to be stored is in register x2</li>
<li>Register x3 holds the dimension of square matrices A, B  and C</li>
</ol>
<p>Below is pseudo code to add two matrices. You can use this as a guide to write the assembly code.</p>
<ol>
<li>Compute the total number of elements in the matrix using the register 'x3'</li>
<li>For each element in A, find the element at the same position in B (i.e. same row and column) and add the 2 values.</li>
<li>Place the result of this addition into result matrix C in the same position.</li>
</ol>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make matrix_addition.elf
RUN_COMMAND: make run
</code></pre>
<p>The solution for this exercise is provided in matrix_addition_solution.s. We recommend that you try to write the program your self before looking at the solution.</p>
<p>Matrix subtraction is very similar to matrix addition. The only difference is that we will use 'Subtract' operation instead of 'Add' operation in the above algorithm. There are 3 different variants of Subtract instructions in ARM architecture.</p>
<ol>
<li>Subtract (extended register)
Subtract (extended register) subtracts a sign or zero-extended register value, followed by an optional left shift
amount, from a register value, and writes the result to the destination register. The argument that is extended from
the <Rm> register can be a byte, halfword, word, or doubleword.</li>
</ol>
<pre><code>SUB &lt;Wd|WSP&gt;, &lt;Wn|WSP&gt;, &lt;Wm&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}  // 32-bit
SUB &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}  // 64-bit
</code></pre>
<ol start="2">
<li>SUB (immediate)
Subtract (immediate) subtracts an optionally-shifted immediate value from a register value, and writes the result to
the destination register.</li>
</ol>
<pre><code>SUB &lt;Wd|WSP&gt;, &lt;Wn|WSP&gt;, #&lt;imm&gt;{, &lt;shift&gt;} // 32-bit
SUB &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, #&lt;imm&gt;{, &lt;shift&gt;}   // 64-bit
</code></pre>
<ol start="3">
<li>Subtract (shifted register) subtracts an optionally-shifted register value from a register value, and writes the result to
the destination register.</li>
</ol>
<pre><code>SUB &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;{, &lt;shift&gt; #&lt;amount&gt;}
SUB &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}
</code></pre>
<p>For this exercise use the file exercises/integer_instructions/matrix_subtract.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make matrix_subtract.elf
RUN_COMMAND: make run
</code></pre>
<p>We recommend that you try to write the program your self before looking at the solution in matrix_subtract_solution.s.</p>
<h2 id="printing-the-fibonacci-series"><a class="header" href="#printing-the-fibonacci-series">Printing the Fibonacci series</a></h2>
<p>Fibonacci series, named after an Italian mathematician, is a sequence of numbers, where every number is sum of the preceding two numbers. The first two numbers of the series are '0' and '1'.</p>
<p>Fibonacci series is:
<code>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, . . . </code></p>
<p>We can notice that every number in this series is the sum of the preceding two numbers. The objective of this exercise, is to write code to store first N numbers of Fibonacci series in an array. The file exercises/integer_instructions/fibonacci.s has to be used for this challenge. Here is the information you need to write this program:</p>
<ol>
<li>The number of elements to be stored in the array is available in register x0</li>
<li>The memory address where fibonacci series will have to be stored is available in register x1</li>
</ol>
<p>Below is a pseudo code to generate the fibonacci series. You can use this as a guide to write the assembly code.</p>
<ol>
<li>Store value '0' and '1' as the first and second elements of array</li>
<li>Use a loop to store elements 2 to N of array so that each element is sum of previous two elements</li>
</ol>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make fibonacci.elf
RUN_COMMAND: make run
</code></pre>
<details>
  <summary>The solution to this exercise is below (also in exercises/integer_instructions/fibonacci_solution.s)</summary>
<pre><code class="language-armasm">    // Your code starts here

    // 0th of the series is 0
    mov    w2, #0
    str    w2, [x1]

    // 1st of the series is 1
    mov    w2, #1
    str    w2, [x1, #4]

    // Subtract the 2 values that has been initialized above from the size
    sub    w3, w0, #2

    // Increment the index
    add    x0, x1, #4

    // Determine the address of last element of array
    add    x3, x0, x3, uxtw 2

    mov    w1, #1
loop:

    // Load the previous-1 value. Previous value is already available in register w1
    ldr    w2, [x0, #-4]

    // Add the previous 2 numbers in the series
    add    w1, w1, w2

    // Increment the index
    add    x0, x0, #4

    // Store the value in array
    str    w1, [x0]

    // Check if we have stored required number of elements
    cmp    x0, x3

    // Branch back to beginning of loop if there are more elements
    bne    loop

    // Your code ends here
</code></pre>
</details>
<h1 id="logic-operations"><a class="header" href="#logic-operations">Logic Operations</a></h1>
<p>In this section we introduce a few more commonly used logic instructions. We will do this through a series of assembly programs.</p>
<p>Logical instructions are the instructions which perform basic logical operations such as OR, AND, XOR, and so on. The logical operations operate on individual bits of the register.</p>
<ul>
<li>The AND operation returns 1, if the matching bits from both the operands are 1, otherwise it returns 0.</li>
<li>The OR operator returns 1, if the matching bits from either or both operands are one. It returns 0, if both the bits are zero.</li>
<li>The XOR operation sets the resultant bit to 1, if and only if the bits from the operands are different. If the bits from the operands are same (both 0 or both 1), the resultant bit is cleared to 0.</li>
<li>The NOT operation reverses the bits in an operand.</li>
</ul>
<h2 id="print-the-xor-truth-table-eor"><a class="header" href="#print-the-xor-truth-table-eor">Print the XOR truth table (EOR)</a></h2>
<p>A truth table is used to specify the output value for each possible combination of input values. The figure below shows the truth table for NOT, AND, OR and XOR operations.</p>
<p><img src="images/truth_table.png" alt="Truth Table" title="Truth Table" /></p>
<p>The objective of this exercise, is to print the truth table for XOR operation. For this exercise use the file exercises/integer_instructions/xor_truth_table.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make xor_truth_table.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="multiply-and-divide-by-a-power-of-2-using-logical-left-shiftlsl-and-logical-right-shiftlsr-instructions"><a class="header" href="#multiply-and-divide-by-a-power-of-2-using-logical-left-shiftlsl-and-logical-right-shiftlsr-instructions">Multiply and divide by a power of 2 using Logical Left Shift(LSL) and Logical Right Shift(LSR) instructions</a></h2>
<p>We will start by first introducing the shift instructions:</p>
<ul>
<li>Logical Shift Left (LSL): The LSL instruction performs multiplication by a power of 2.</li>
<li>Logical Shift Right (LSR): The LSR instruction performs division by a power of 2.</li>
<li>Arithmetic Shift Right (ASR): The ASR instruction performs division by a power of 2, preserving the sign bit.</li>
<li>Rotate right (ROR): The ROR instruction performs a bitwise rotation, wrapping the bits rotated from the LSB into the MSB</li>
</ul>
<p><img src="images/shift_ops.png" alt="Shift Operators" title="Shift operators" /></p>
<p>The Logical Left Shift(LSL) and Logical Right Shift(LSR) instructions can also be used to perform multiply and divide operations:</p>
<ul>
<li>Multiplication with powers of 2 can be performed using left shift operator(LSL).</li>
<li>Division by powers of 2 can be performed using right shift operator(LSR).</li>
</ul>
<p>The objective of this exercise is to multiply and divide a number by a power of 2 using LSL and LSR instructions.</p>
<ol>
<li>Multiply the 32-bit value in register w0 by 128 using Left Shift Operator and place the result in register w8</li>
<li>Divide  the 32-bit value in register w1 by 64 using Right Shift Operator and place the result in register w9</li>
</ol>
<p>For this exercise use the file exercises/integer_instructions/shift_to_multiply_divide.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make shift_to_multiply_divide.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="count-the-number-of-1s-in-a-register"><a class="header" href="#count-the-number-of-1s-in-a-register">Count the number of 1's in a register</a></h2>
<p>The objective of this exercise is to count the number of 1s in the binary representation of an integer.</p>
<p>For example, let us consider an input value of 19. The binary representation of 19 is 10011 and has 3 set bits. Therefore, the result should be printed as 3. The figure below illustrates this.</p>
<p><img src="images/count_set_bits.png" alt="Count number of 1's in register" title="Count number of 1's in register" /></p>
<p>Below is a pseudo code to count 1's in register. You can use this as a guide to write the assembly code.</p>
<ol>
<li>Loop through all bits in an integer</li>
<li>Use a shift instruction to select the bit to be checked</li>
<li>Check if bit is set and increment the count if bit is set</li>
</ol>
<p>For this exercise use the file exercises/integer_instructions/count_ones.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make count_ones.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="count-leading-zeros-using-clz-instruction"><a class="header" href="#count-leading-zeros-using-clz-instruction">Count leading zeros using CLZ instruction</a></h2>
<ul>
<li>Refer earlier example in integer sectiom</li>
</ul>
<p>Counting leading zeroes in a number is such a common requirement in programs that the ARM ISA includes a specific instruction that does the job.</p>
<blockquote>
<p>clz &lt;Wd&gt;, &lt;Wn&gt;</p>
</blockquote>
<p>This instruction counts the nimber of leading zeroes of the number stored in Wn and places the result in Wd!! The result value is 32 if no bits are set in the source register, and zero if bit 31 is set. In this execercise let us redo the exercise using this instruction.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make clz_inst.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="what-we-learnt-this-chapter"><a class="header" href="#what-we-learnt-this-chapter">What we learnt this chapter</a></h2>
<ul>
<li>Arrays and how they appear in memory</li>
<li>Integer instructions - ADD, SUB, TST, MUL</li>
<li>Transferring data between registers - MOV</li>
<li>Bit operations - AND, EOR, ORR, ASR, LSL, LSR, ROR</li>
</ul>
<p>In this section we learnt a few commonly used AArch64 integer instructions. There are several more integer instructions, and also different forms of the above instructions, defined in the ISA. We leave it to the reader to look up the <a href="https://developer.arm.com/documentation/ddi0487/ga">ARM ARM</a> for a comprehensive list.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="memory_inst.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="condition_flags.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="memory_inst.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="condition_flags.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
