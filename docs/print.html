<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Part 1: Introduction to Low-level Programming in C and Arm AArch64 Assembly</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="preface.html">Preface</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="tool_installation.html"><strong aria-hidden="true">2.</strong> Tool Installation</a></li><li class="chapter-item expanded "><a href="comp_overview.html"><strong aria-hidden="true">3.</strong> Computer System Overview</a></li><li class="chapter-item expanded "><a href="arm_exec_state.html"><strong aria-hidden="true">4.</strong> Arm Registers and Execution State</a></li><li class="chapter-item expanded "><a href="binary_representation.html"><strong aria-hidden="true">5.</strong> Binary Representation of Integers</a></li><li class="chapter-item expanded "><a href="starting_assembly.html"><strong aria-hidden="true">6.</strong> Arm AArch64 Assembly Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="memory_inst.html"><strong aria-hidden="true">6.1.</strong> Memory Instructions</a></li><li class="chapter-item expanded "><a href="integer_inst.html"><strong aria-hidden="true">6.2.</strong> Integer Instructions</a></li></ol></li><li class="chapter-item expanded "><a href="condition_flags.html"><strong aria-hidden="true">7.</strong> Condition Flags</a></li><li class="chapter-item expanded "><a href="stack.html"><strong aria-hidden="true">8.</strong> The Stack</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">9.</strong> Functions</a></li><li class="chapter-item expanded "><a href="c_programming.html"><strong aria-hidden="true">10.</strong> Programming in C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="c_variables.html"><strong aria-hidden="true">10.1.</strong> Variables and Data types</a></li><li class="chapter-item expanded "><a href="c_syntax.html"><strong aria-hidden="true">10.2.</strong> C Language Syntax</a></li><li class="chapter-item expanded "><a href="c_exercises.html"><strong aria-hidden="true">10.3.</strong> C Programming Exercises</a></li><li class="chapter-item expanded "><a href="c_pointers.html"><strong aria-hidden="true">10.4.</strong> Introduction to Arrays and Pointers in C</a></li></ol></li><li class="chapter-item expanded "><a href="c2assembly.html"><strong aria-hidden="true">11.</strong> From C Programs to Assembly Code</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="disassembly.html"><strong aria-hidden="true">11.1.</strong> Disassembly examples</a></li></ol></li><li class="chapter-item expanded "><a href="conclusion_part1.html"><strong aria-hidden="true">12.</strong> Conclusion</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">13.</strong> References</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Part 1: Introduction to Low-level Programming in C and Arm AArch64 Assembly</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="preface"><a class="header" href="#preface">Preface</a></h1>
<p>This book is an introduction to the ARM Cortex-A AArch64 architecture and programming in the C language. Readers will learn the architecture by writing programs in ARM assembly and C programming languages. The book covers a subset of the instruction set architecture (ISA) and provides several exercises for readers to practise and develop familiarity with the ISA. Also included are important portions of the ARM architecture including interrupts and exceptions, exception levels, virtual memory etc. In addition to assembly programming the book also serves as an introduction to the venerable C programming language. The book strives to explain the relationship between code written in C and its equivalent in ARM assembly. The objective is to give readers a glimpse into what high-level code translates to in assembly language. Readers will understand things like what happens on a function call, how values are passed into functions and returned from them, and what is the overhead of function calls. They will understand how control flow really works, what pointers are under the hood, and the real difference between passing by value or reference.</p>
<p>The book would be useful to anyone looking to pursue a career in embedded systems, compilers, OS development, computer security, or CPU verification. To make it accessible to a wider audience, it has been written so that readers require no prior experience in programming. Therefore, experienced programmers may find it a bit tedious and verbose. If you are one such reader, we encourage you to skim through the book dipping into areas that are new or interesting and skipping ones you already know. </p>
<p><strong>Note:</strong> 
The contents of this book and associated code hosted in GitHub are provided for educational purposes only. Specifically, this material is not official documentation of the ARM architecture or the C programming language. All opinions expressed are solely that of the authors.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>This is <strong>Part 1</strong> of a series of online books which will give readers an introduction to the ARM AArch64 architecture using ARM assembly language and the C programming language. It takes a hands-on approach to teaching programming and provides explanations along with exercises. Readers will benefit if they follow along by doing the exercises themselves. Ideally, after the first exercise, readers should try to write the programs on their own. We will initially learn to write programs in assembly language and then in the C programming language.  We strongly encourage readers to try solving each exercise in this book by themselves. Refer to the provided solution only when stuck and/or to learn alternative solutions to exercises.</p>
<BR>
<p><strong>Who is this book for?</strong></p>
<p>This book will be useful to those interested in learning how processors work at the lowest level. Specifically, it can be useful for readers interested in working in embedded systems, OS development, compiler development, computer security, and CPU verification.</p>
<p>The book assumes readers have no prior knowledge of computer architecture or experience with any programming language. The book is self-contained and it is intended that everyone with high-school level mathematics background will be able to follow along.</p>
<BR>
<p><strong>What will you learn?</strong></p>
<p>This material teaches how microprocessors work under the hood. Readers will learn how actual computation is performed using the basic instructions that a processor can execute. They will learn how system software works with the underlying hardware.</p>
<p>Part 1 (i.e. this book) covers:</p>
<ul>
<li>Arm AArch64 architecture for application programmers</li>
<li>Writing code in ARM assembly language</li>
<li>An introduction to programming in C</li>
<li>How C code relates to assembly</li>
</ul>
<p>All the code written in this book runs &quot;bare-metal&quot;. This means there is no underlying OS or any other software to support the code you will learn to write. Everything that is executed by the processor will be written by the reader (with some support from template code provided in the book).</p>
<BR>
<p><strong>Why learn assembly programming and CPU architecture?</strong></p>
<p>High-level languages (HLLs) abstract a lot of detail from the programmer. This is useful because abstraction hides underlying complexity and therefore makes programming easier and faster. Today there are many HLLs that are popular - Java, Swift, Python, C#, Kotlin etc. Developing applications in HLLs enables fast development time, abstraction, and portability at the cost of some overheads. For many software projects this is a very reasonable tradeoff. Especially since modern computer systems are much faster than their counterparts from a decade ago. HLL applications are efficiently translated by compilers into assembly language. Programmers developing applications do not need a detailed understanding of the CPU architecture and the language directly understood by the CPU (assembly).</p>
<p>However, there are some areas in software development and computer design that require programmers to have a good knowledge of CPU architecture, assembly language  and some HLL (usually C or C++). For example:</p>
<ul>
<li>Embedded systems</li>
<li>Compiler development</li>
<li>Operating System development</li>
<li>Pre- and post-silicon verification of CPUs and computer systems</li>
<li>Low level code optimization</li>
<li>Cyber Security - analyzing and developing exploits, reverse-engineering etc.</li>
</ul>
<p>Assembly language is specific to the architecture used by the system (e.g. ARM, x86, PowerPC etc.) and is not portable across processor types. It is the most direct way for programmers to interact with the processor and its peripherals. So there are no layers of abstraction or obfuscation between the programmer and the hardware. By learning assembly programming one can understand how a processor works under the hood. How computations are performed and how resources like memory are virtualized so that it can be shared among multiple applications. Coupling that knowledge with a programming language like C gives the programmer the skills to work in the domains listed above.</p>
<p>The ARM architecture is ubiquitous and used in a range of devices from wrist watches to super computers. This book teaches readers the fundamentals of the AArch64 architecture and assembly language. It also presents an introduction to the C programming language and explains how code written in C relates to assembly.</p>
<h2 id="hardware-and-software-requirements"><a class="header" href="#hardware-and-software-requirements">Hardware and Software Requirements</a></h2>
<p>To follow the exercises in this book you need a PC or a Mac computer with 4GB of memory or more. In addition, the computer will need to have 5GB of free disk space. The supported operating systems are listed below. The computer should be running the specified version or later.</p>
<p>macOS 10.15 (Catalina), Windows 10, and Ubuntu 20.04 LTS</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-of-required-tools"><a class="header" href="#installation-of-required-tools">Installation of Required Tools</a></h1>
<p>You will need the following software tools for following along this book</p>
<ul>
<li>GCC for ARM: A compiler to compile your programs into binary.</li>
<li>QEMU: This is a software emulator that we will use to emulate the Raspberry Pi</li>
<li>Make tool for Windows 10</li>
<li>Git: A version control software. You will use this to get a copy of the code in this book from our Git repository.</li>
</ul>
<h2 id="windows-10"><a class="header" href="#windows-10">Windows 10</a></h2>
<h3 id="gcc-compiler"><a class="header" href="#gcc-compiler">GCC compiler</a></h3>
<p>The compiler is available as a free download from <a href="https://developer.arm.com/downloads/-/gnu-a">here</a>. The specific version you need for <strong>Windows 10</strong> is under the &quot;Windows mingw&quot; section and the &quot;aarch64-none-elf&quot; version. Download the <em>.tar.xz</em> file.</p>
<p>This is a compressed archived file containing all the compiler, assembler and disassembler tools needed for this book. To extract these files you will need a program like <a href="https://www.7-zip.org/">7-zip</a>. Once you install 7-Zip you can open the tar.xz file using that program. </p>
<p>Opening the archive file will give you a directory. Move that directory to your home directory (in windows this will be C:\Users&lt;Your_User_Name&gt;)</p>
<h3 id="qemu"><a class="header" href="#qemu">QEMU</a></h3>
<p>Preferably running 64-bit Windows 10</p>
<ol>
<li>Download <a href="https://www.qemu.org/download/#windows">QEMU</a> and click on 64-bit version (select the 32-bit version if you are using 32-bit Win 10)</li>
<li>Download the latest released installer executable</li>
<li>Run installer and follow instructions to install</li>
</ol>
<h3 id="make"><a class="header" href="#make">Make</a></h3>
<ol>
<li>Download <strong>Make for Windows</strong> from <a href="http://gnuwin32.sourceforge.net/packages/make.htm">here</a>. </li>
<li>Down load the installer executable by selecting <strong>Complete package, except sources</strong> option.</li>
<li>Run installer and follow instructions to install</li>
</ol>
<h3 id="git"><a class="header" href="#git">Git</a></h3>
<p><strong>Git</strong> is a source control management system. Download the installer from <a href="https://git-scm.com/download/win">here</a> and follow the instructions in the installer.</p>
<p>The installation includes an application named <strong>Git bash</strong>. <strong>Git Bash</strong> is a Linux-based command line environment. It allows users to type various <strong>Git commands</strong> that make source code management easier. </p>
<p>After the installation of Git is complete, open the <strong>Git Bash</strong> application using the <strong>Start</strong> menu. This will open a terminal window with a command prompt and it current directory by default will be your home directory.</p>
<p>Create a subdirectory named <strong>low_level_prog</strong> and navigate into it by running following commands in the <strong>Git bash</strong> terminal window.</p>
<pre><code>mkdir low_level_prog
cd low_level_prog
</code></pre>
<p>Now, type the following to checkout code from the repository:</p>
<pre><code>git clone https://github.com/hrishim/llvl_prog1_code.git
</code></pre>
<h3 id="setting-up-the-environment"><a class="header" href="#setting-up-the-environment">Setting up the environment</a></h3>
<ol>
<li>Navigate into the code checout:</li>
</ol>
<pre><code>cd llvl_prog1_code
</code></pre>
<ol start="2">
<li>Open <strong>dotbashrc</strong> file using vim editor (included as part of Git bash installation):</li>
</ol>
<pre><code>vim dotbashrc
</code></pre>
<p><strong>NOTE:</strong> : If you prefer to use a different editor like <strong>notepad</strong>, you can replace <strong>vim</strong> with the editor name of your preference. For example: <em>notepad dotbashrc</em> </p>
<ol start="3">
<li>Fill up the installation paths of Qemu, GCC and Make in space provided within the dotbashrc file:</li>
</ol>
<pre><code># Please fill the actual installation path of Qemu below:
# For example:
# export LOCAL_QEMU_PATH=&quot;/c/Program Files/qemu&quot;
export LOCAL_QEMU_PATH=&quot;&quot;

# Please fill the actual installation path of ARM GCC below:
# For example:
# export LOCAL_GCC_PATH=&quot;$HOME/gcc-arm-10.2-2020.11-mingw-w64-i686-aarch64-none-elf&quot;
export LOCAL_GCC_PATH=&quot;&quot;

# Please fill the actual installation path of make below:
# For example:
# export LOCAL_MAKE_PATH=&quot;$HOME/make-3.81-bin&quot;
export LOCAL_MAKE_PATH=&quot;&quot;
</code></pre>
<p><strong>NOTE:</strong> 
While specifying any path in this file, following minor modifications to Windows paths must be made:</p>
<ul>
<li>Replace backslashes(\) in Windows paths with forward slashes(/).</li>
<li>Remove the first colon after the drive letter, and add a slash at the beginning.</li>
<li><strong>$HOME</strong> can be used to refer to the home directory</li>
<li>For example: (1) Windows path: &quot;C:\Program Files/qemu&quot; would become &quot;/c/Program Files/qemu&quot;. (2) &quot;C:\Users&lt;Your_User_Name&gt;\make&quot; would become &quot;$HOME/make&quot;</li>
</ul>
<ol start="4">
<li>Exit the editor and source the <strong>dotbashrc</strong> file to setup the environment</li>
</ol>
<pre><code>source dotbashrc
</code></pre>
<ol start="5">
<li>Test if it is working by typing the following command in the terminal window:</li>
</ol>
<pre><code>qemu-system-aarch64 --version
</code></pre>
<p>You should see an output like below. The version you see may be different and that is OK.</p>
<pre><code>QEMU emulator version 6.0.0 (v6.0.0-11869-g800a25ea45-dirty)
Copyright (c) 2003-2021 Fabrice Bellard and the QEMU Project developers
``

**Additional help (external link):** [Installing QEMU on Windows](https://www.youtube.com/watch?v=SHMUMeEzSS0) (see the path setting)
 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="computer-system-overview"><a class="header" href="#computer-system-overview">Computer System Overview</a></h1>
<p>This section gives an overview of the main components of a computer system. It is not a comprehensive explanation of everything on a computer board. The intention is to provide readers with sufficient context to understand the rest of this book.</p>
<p>The components in a computer system are mounted on a board and connected to each other by wires embedded in the board. These components include a system on chip (SoC), peripherals and connectors. The SoC is the component that performs computation. Everything else on the board is to enable the SoC to perform its work and for the external world (including human users) to interact with the SoC. This is a general description of a computer system. Every individual system will have some differences. The peripherals on the board may be different. Also, some systems may have high-speed interconnects such as PCI that allows extension cards to be connected to the system.</p>
<p>In part one of this book we will be working with a <strong>software model</strong> of the popular single board computer -<br />
<a href="https://www.raspberrypi.org/">Raspberry Pi</a>. The image below shows a Raspberry Pi 3 B+ model single-board computer. The big silver colored square chip with text on it is the SoC.</p>
<!--
![Raspberry Pi Board](https://upload.wikimedia.org/wikipedia/commons/9/90/Front_of_Raspberry_Pi.jpg)
-->
<p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b8/Raspberry_Pi_3_B%2B_%2839906370335%29.png" alt="Raspberry Pi Board Front" /></p>
<!-- Write your comments here -->
<p>The <a href="https://www.raspberrypi.com/documentation/computers/processors.html">SoC used in this board</a> is designed by Broadcom. There are multiple Arm CPUs inside the SoC to perform computations. In addition to the CPUs there are other components such as a graphics chip, memory etc in the SoC.</p>
<p>The CPUs (also called cores) are based on the Arm AArch64 architecture specification. We will be learning AArch64 assembly language that can be used to write programs to direct what the CPU should do - i.e. the specific steps they need to perform for things like computing the fibonacci series etc.</p>
<p>Besides the main SoC there are other components on the chip. The black square with the text &quot;LAN 7515&quot; is another micro-chip which is a USB hub and a controller for Ethernet. In addition two these chips there are USB ports, a micro USB port, an ethernet port and GPIO pins on the board.</p>
<p>Here is a picture of the back of the board. The black square that is aligned with the SoC on the top of the board is the DRAM (memory) that the processor uses to store data. </p>
<p><img src="./images/RPi_3B_back.jpg" alt="RPi Back" /></p>
<p>The main item of interest for us are the ARM cores inside the SoC. Almost all of the material in this book will be about how to write code that can be executed by these cores. The SD-card slot where a storage card can be affixed is the silver recrtangle on the right side.</p>
<!--
## The System On a Chip

![Twirling](images/animated-twirl-twirl.gif "Twirling")
-->
<h2 id="the-soc"><a class="header" href="#the-soc">The SoC</a></h2>
<p>The picture below shows a block diagram of the components inside a typical SoC. </p>
<p><img src="./images/rpi_soc.png" alt="SoC block diagram" /></p>
<p>In the top left of the diagram is the CPU with multiple cores. The CPU is the main computation engine inside the SoC. Many modern CPUs are multi-processors, meaning they have more than one processing core in the CPU. Each CPU has a L1 cache. Caches are are fast SRAM memory of limited capacity that the CPU can access quickly. Data that is frequently used by the CPU is stored in caches so that it can be accessed faster than from DRAM.</p>
<p>The cores share some of the components on the CPU and SoC. Usually they will share the level-2 cache, level-3 cache (if any), interconnect, memory, and I/O peripherals. The SoCs in Raspberry Pi 3 boards have quad-core ARM Cortex A53 CPUs. Each core has a 32KB L1 data cache and a 48KB L1 instruction cache. The cores share a 1MB L2 cache.</p>
<p>All cores in the CPU share a main memory unit (MMU). This unit is used to translate <em>virtual addresses</em> used by the CPUs to <em>physical addresses</em>. Virtual and physical addresses will be covered in part two of this book. The CPU connects to memory and peripherals - such as ethernet, DMA, USB, timer, UART, SPI, I<sup>2</sup>C,  I<sup>2</sup>S, PWM etc. - via the interconnect which is labeled as AMBA/AXI in the diagram.</p>
<h2 id="the-arm-cores"><a class="header" href="#the-arm-cores">The ARM Cores</a></h2>
<p>The CPU cores are the components that perform computation. The cores are programmable, meaning that they understand a set of instructions and the programmer can write programs by issuing instructions from this set to the <em>Core</em>. These CPUs conform to the ARM Cortex-A architecture. The architecture defines the instructions and their encoding, resources available to the <em>Cores</em>, and some other features like how memory is addressed etc.</p>
<p>The block diagram below shows a high-level block diagram of the inside of an typical CPU core. The CPU consists of an execution pipeline comprising of </p>
<ul>
<li>Program counter: Tracks the current instruction being executed</li>
<li>logic gates to fetch instructions, decode them, execute and write results</li>
<li>caches and registers to store results</li>
<li>memory structures to store in-flight instructions, data, meta-data (for branch prediction, pre-fetching etc.)</li>
</ul>
<p><img src="./images/cpu_pipe.png" alt="SoC block diagram" /></p>
<p>How do the cores execute the programmers commands? </p>
<p>Well, the programmer writes the program in assembly language or a higher level language like C. The program is compiled into a binary file using a compiler. The binary file is an encoding of the instructions (as specified in the architecture manual). This file is loaded into <em>memory</em> and the <em>program counter</em> (PC) of the CPU core is set to the memory address of the first instruction in memory. Multi-processor SoCs have multiple programmable CPU cores. Each of them have their own program counter. They can execute code independent of each other.</p>
<p>The logic blocks of the CPU then read the instruction from memory (<em>instruction fetch</em>) location pointed to by the PC, decode it, read the required data for the operation, perform the operation (<em>execute</em>) and write results back to registers or to memory (store instructions).</p>
<p>Note that the <em>fetch stage</em> of the processor works automatically to load instructions from memory into the processor pipeline. No explicit program instruction is needed for this purpose. However, to move <strong>data</strong> to/from memory from/to <em>registers</em> the programmer has to use load and store instructions. Instructions that perform computations read their input values from registers in the <em>register file</em> (i.e. collection of registers) and write the output back to the register file. </p>
<p>The register file is a small memory structure, comprising of multiple registers, that is close to the processor pipeline. It is used to store values required for instructions executing in the processor. Since it is closest to the processing core, it can be accessed quickly. Typically registers in the register file can be read/written in one CPU cycle. However, due to area and latency constraints the number of registers available is usually small. Therefore, for most programs the entire data needed to be read/written by the program cannot be stored in the register file. ARM is a RISC architecture. So compute instructions cannot directly use data located in memory. Nor can they write results directly back to memory. In this architecture, programmers have to explicitly load data from memory into a register and then use it to compute values. There are separate instructions - distinct from computational ones - to load and store data from memory.</p>
<h2 id="bits-and-bytes"><a class="header" href="#bits-and-bytes">Bits and Bytes</a></h2>
<p>As most readers probably know, computers store and process data as <em>bits</em>. A single bit - binary digit - is the minimum unit of information stored in a computer. A bit can can hold one of two values - 0 or 1. A group of 8 bits, called <em>byte</em>, is usually the smallest addressable unit of memory. In a modern computer system (most of them anyway) memory in a computer consists of a millions of bits that are grouped into bytes. Every byte has a unique address and can be individually loaded in to registers using specific instructions. A byte is 8-bits. A <em>word</em> is 4 bytes. A <em>double-word</em> is 8 bytes and a <em>half-word</em> is 2 bytes. These are the data sizes one will commonly encounter in assembly programming.</p>
<p>In Part 1 you will learn how to write programs that run on the Arm Cores. In the process we will learn the Arm A-class processor architecture, Arm assembly, and some C programming.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arm-registers-and-processor-execution-state"><a class="header" href="#arm-registers-and-processor-execution-state">ARM Registers and Processor Execution State</a></h1>
<p>CPU Cores, also called processors, are programmable hardware that can perform computation. Programmable meaning they can be given a set of instructions - encoded as bits - and they will perform the computation as directed in the instructions.</p>
<p>What instructions can a programmer give the processor? What resources does the processor have to execute those instructions? These are defined in the processor's architecture. The architecture of ARM processors are specified in the ARM Architecture Reference Manual (see References). The architecture also specifies the instructions that the processor is capable of understanding.</p>
<p>Programmers use these instructions to write programs in assembly language. In subsequent chapters we will learn how to use ARM assembly language to program the processor. This section provides an overview of the resources that an ARM processor has at its disposal to aid in performing computation.</p>
<p>The two resources available to programmers are registers and PSTATE. Registers allow programmers to store a limited amount of data. Instructions can perform operations on register values. The output values generated by instructions are also stored in registers.</p>
<p>Data can also be stored in memory. Usually (almost always), the amount of data that can be stored in memory is much larger than what can be stored in registers. However, in the ARM architecture computational instructions cannot directly operate on data in memory. They can only operate on register values. Special instructions, called Load/Store instructions, are used to transfer data between memory and registers. </p>
<h2 id="arm-registers"><a class="header" href="#arm-registers">ARM Registers</a></h2>
<p>The architecture provides programmers with <strong>31 general purpose registers</strong>. These registers store inputs for computation and the output. They may also be used to store intermediate results of computations.</p>
<p>For example, if a program is used to compute the function:</p>
<blockquote>
<p>L = (A + B) * K</p>
</blockquote>
<p>Registers can be used to hold the values of A, B, and K. Another register can be used to hold the value of the result (L). The result of the addition (A + B) is a temporary value in this context. It is needed to compute the final answer but not necessary after that. This temporary value can also be stored in a register.</p>
<p>The 31 general purpose registers are 64-bits wide. But they can be used either as 64-bit or as 32-bit registers. The registers are named X0-X30 when they are referred to in 64-bit form. They are named W0-W30 when referred to in 32-bit form. From a programmer's perspective, general purpose registers are locations that can be used to store data. The programmer may write to, read from, and re-write registers as required to accomplish their end goal.</p>
<p>The X30 register has a special function. It is used as a link register for procedure calls. The specifics of this function are explained in later chapters.</p>
<p><img src="images/armRegs.png" alt="ARM Registers" title="ARM Registers" /></p>
<p>The general purpose registers can be used by Integer and Logic operation instructions. Another set of 32 registers are available for use with floating-point and SIMD instructions. We will not be using those instructions in this book, the interested reader can consult the ARM architecture reference manual for details.</p>
<p>There are two additional registers with specific functions - stack pointer (SP) and program counter (PC). They cannot be used for general purpose computation. The SP register is a 64-bit register that points to the current &quot;top of stack&quot;. The chapter on Functions will explain this use of this register. The PC register is a 64-bit register that holds the address of the current instruction being executed. This register cannot be written to directly. It is updated by the processor when a branch instruction is executed and on exception entry/return. We will learn more about control flow and exceptions later in this book.</p>
<p>Here is the pseudo code for the operation  L = (A + B) * K:</p>
<pre><code>1. Load K into X0
2. Load A into X1
3. Load B into X2
4. X3 = X1 + X2
5. X0 = X3 * X0   #result is left in X0
</code></pre>
<h2 id="arm-process-state-pstate"><a class="header" href="#arm-process-state-pstate">ARM Process State (PSTATE)</a></h2>
<p>In addition to registers the architecture also provides some <em>state</em> that records information related to computation and exceptions. The process state (PSTATE) comprises of:</p>
<ul>
<li>Condition flags</li>
<li>Exception masking bits</li>
</ul>
<p>There are four condition flags:</p>
<table><thead><tr><th>Flag</th><th>Desc</th></tr></thead><tbody>
<tr><td>N</td><td>Negative flag</td></tr>
<tr><td>Z</td><td>Zero flag</td></tr>
<tr><td>C</td><td>Carry flag</td></tr>
<tr><td>V</td><td>Overflow flag</td></tr>
</tbody></table>
<p>These flags are 1-bit each, so they can have only values of 0 (clear) or 1 (set). <strong>Certain instructions in the ISA set these flags if the computation results in specific conditions.</strong></p>
<p>The N flag represents the sign of the result of the previous operation. If say the operation was an addition (or subtraction, multiplication, division etc.) and the result was a negative number then this flag is set. If the result was a positive number then this flag is cleared.</p>
<p>The Z flag, when set, indicates that the output of the previous instruction was zero. </p>
<p>The C flag is called the carry flag. This flag is set if an arithmetic operation results in an arithmetic <em>carry</em> or <em>borrow</em>. The V flag indicates that the previous operation resulted in an arithmetic <em>overflow</em>. The explanation for when these flags are set/cleared requires an understanding of binary arithmetic and therefore will be provided in the corresponding section.</p>
<p>The PSTATE includes four exception masking bits.</p>
<table><thead><tr><th>Exception Masking</th><th>Description</th></tr></thead><tbody>
<tr><td>D</td><td>Debug exception mask</td></tr>
<tr><td>A</td><td>SError interrupt mask</td></tr>
<tr><td>I</td><td>IRQ interrupt mask</td></tr>
<tr><td>F</td><td>FIQ interrupt mask</td></tr>
</tbody></table>
<p>We will discuss exceptions and masking exceptions in part 2 of this book (not yet available). For now, just know that they are part of the PSTATE.</p>
<h2 id="what-we-learned-this-chapter"><a class="header" href="#what-we-learned-this-chapter">What we learned this chapter</a></h2>
<ol>
<li>ARM general purpose registers </li>
<li>ARM PSTATE</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="binary-representation-of-integers"><a class="header" href="#binary-representation-of-integers">Binary Representation of Integers</a></h1>
<p>This section we will learn about number representation using the binary system. Representation only governs how numbers are represented for writing, storing in memory etc. It makes no difference to the result of arithmetic operations. Meaning that arithmetic operations like addition, subtraction, multiplication, and division will have the same result regardless of whether the representation is in decimal, binary, hexadecimal, octal etc.</p>
<p>We are used to counting using the decimal number system. This system has ten symbols (decimal numerals) to represent numbers, namely - 0 1 2 3 4 5 6 7 8 9. Of course, these symbols can represent values greater than ten. For example, after counting from 0 till 9 we run out of symbols for ten. To represent ten and higher numbers more than one of those symbols is used - 10, 11, 12...10521... etc. A special symbol is pre-fixed to numbers to represent negative numbers (-1, -2, -3... etc.).</p>
<p>OK, so all of this number representation is elementary school material. What is the point of all this? The main point is that numbers are represented with symbols. Modern computers use <em>binary</em>  representation for storing and operating on numbers. The decimal number format uses 10 symbols (11 actually if you count the minus sign for negative numbers) the binary number format uses just two symbols.</p>
<p>Therefore, when working with computers at the lowest level, it is important to know how numbers are represented and how arithmetic operations are performed in binary .</p>
<hr />
<p><strong>Note:</strong></p>
<p>Are there computers that use representations other than binary? There were a few that used ternary logic (i.e. base: 3). However, all computers that one is likely to encounter today use binary representation. Ternary and other base forms are outside the scope of this book.</p>
<hr />
<p>Representation only governs how numbers are represented for writing, storing in memory etc. It makes no difference to the result of arithmetic operations. Meaning that arithmetic operations like addition, subtraction, multiplication, and division will have the same result regardless of whether the representation is in decimal, binary, hexadecimal, octal etc.</p>
<h2 id="binary-representation"><a class="header" href="#binary-representation">Binary Representation</a></h2>
<p>The binary number system uses two numerals - 0 and 1. So, just like in the decimal system, more than one of those symbols are needed to represent 2 and greater. The table below shows decimal numbers and their equivalent binary:</p>
<table><thead><tr><th>Decimal</th><th>Binary</th></tr></thead><tbody>
<tr><td>0</td><td>0b0</td></tr>
<tr><td>1</td><td>0b1</td></tr>
<tr><td>2</td><td>0b10</td></tr>
<tr><td>3</td><td>0b11</td></tr>
<tr><td>4</td><td>0b100</td></tr>
<tr><td>5</td><td>0b101</td></tr>
<tr><td>6</td><td>0b110</td></tr>
<tr><td>7</td><td>0b111</td></tr>
<tr><td>8</td><td>0b1000</td></tr>
<tr><td>9</td><td>0b1001</td></tr>
<tr><td>10</td><td>0b1010</td></tr>
<tr><td>100</td><td>0b1100100</td></tr>
<tr><td>1000</td><td>0b1111101000</td></tr>
</tbody></table>
<p>When referring to binary numbers in code it is common to prefix it with special characters to indicate the number is in binary representation. The convention is to use the prefix 0b for binary numbers and 0x for hexadecimal numbers. Decimal numbers have no prefix.</p>
<p>In the <em>decimal system</em>, all numbers that are powers of 10, are represented with the symbol 1 followed by zero or more 0s. Examples include 1, 10, 100 etc. The position of numerals representing a number is called &quot;decimal place&quot;. So a number like say 25 has one decimal numeral in the 10's place and another in the 1's place.</p>
<pre><code>25 = 2 * 10^1 + 5 * 10^0

542 = 5 * 10^2 + 4 * 10^1 + 2 * 10^0

Here ^ means raised to the power.
Recall that any number raised to power 0 is 1. So 10^0 is 1.
</code></pre>
<p><strong>The binary number system uses base 2.</strong> This means the position of every numeral is a power of 2. Also, in binary representation, numbers that are a power of two are represented with the numeral 1 followed by 0s. This is similar to power of 10 numbers in the decimal system!!</p>
<p>For example, the number 2 in binary is 0b10. Why is that? Because 0b10 is</p>
<pre><code>1 * 2^1 + 0 * 2^0 = 2

Here ^ means raised to the power.
</code></pre>
<p><em>Decimal numbers</em> that are powers of 10 are represented with the numeral 1 followed by the numeral 0. The number of 0s depends on the power of 10. In <em>binary</em> the same applies to numbers that are powers of 2. In the table above, the binary equivalent of 2, 4 and 8 all have only one numeral set to 1 and it is followed by 0s.</p>
<h2 id="converting-from-binary-to-decimal-and-vice-versa"><a class="header" href="#converting-from-binary-to-decimal-and-vice-versa">Converting From Binary to Decimal and Vice Versa</a></h2>
<p>It is pretty straight forward to convert a number from binary to decimal. All it requires is to multiply the binary numeral with the appropriate power of 2.</p>
<p>For example, the binary number 0b10 can be converted to decimal the following way:</p>
<pre><code>Binary number: 0b10

1 * 2^1 + 0 * 2^0 = 2

Decimal: 2
</code></pre>
<p>Another example,</p>
<pre><code>Binary number: 0b1001

1 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0 = 8 + 0 + 0 + 1 = 9

Decimal: 9
</code></pre>
<p>Converting from decimal to binary is a just a touch more difficult because it requires division. It is done by repeatedly dividing the number and recording the remainder. The division is continued until what remains is 0.</p>
<p>Here is an example of how to convert the decimal number 8 to binary. We divide 8 by 2 successively until the quotient is 0. The quotient and remainder of each step of the division is shown below.</p>
<pre><code>Decimal number: 8

	2 | 8
	  ----
	2 | 4  - 0
	  ----
	2 | 2  - 0
	  ----
	2 | 1  - 0
	  ----
	    0  - 1
</code></pre>
<p>The binary representation is the remainder read backwards. So in this instance it will be  0b1000 (the leading 0 is dropped).</p>
<h2 id="practice-converting-number-formats"><a class="header" href="#practice-converting-number-formats">Practice converting number formats</a></h2>
<p>Convert the following binary numbers to decimal: 0b100, 0b1011, 0b10000, 0b11001</p>
<details>
  <summary>Click here to see answers.</summary>
<table><thead><tr><th>Binary</th><th>Decimal</th></tr></thead><tbody>
<tr><td>0b100</td><td>4</td></tr>
<tr><td>0b1011</td><td>11</td></tr>
<tr><td>0b10000</td><td>16</td></tr>
<tr><td>0b11001</td><td>25</td></tr>
</tbody></table>
</details>
<p>Convert the following decimal numbers to binary: 52, 29, 17, 32</p>
<details>
  <summary>Click here to see answers.</summary>
<table><thead><tr><th>Decimal</th><th>Binary</th></tr></thead><tbody>
<tr><td>52</td><td>0b110100</td></tr>
<tr><td>29</td><td>0b11101</td></tr>
<tr><td>17</td><td>0b10001</td></tr>
<tr><td>32</td><td>0b100000</td></tr>
</tbody></table>
</details>
<h2 id="binary-representation-in-computers"><a class="header" href="#binary-representation-in-computers">Binary representation in computers</a></h2>
<p>Larger numbers may need more numerals for representation. For example, 0b100000000 (256) requires nine binary digits while 0b1 (1) requires just one binary digit. In practice it is very difficult to implement logic circuitry (adders, multipliers etc.) to account for the variation in binary digits. Therefore, computers use fixed-width integers. This means that numbers are represented with a fixed number of digits. The most common widths are 8-bit (byte), 16-bit (half-word), 32-bit (word), 64-bit (double word).</p>
<p>Fixed-width representations can be used to represent numbers from 0 up to a maximum value. That maximum value is determined using the formula 2<sup>N</sup> - 1, where N is the width. The largest integer that can be represented in 8-bit fixed-width is</p>
<pre><code> 2^8 - 1 = 256 - 1 = 255
 8-bit binary number can represent numbers in the range 0-255
</code></pre>
<p>This is a small number range and computers will be of limited use if all they can represent are numbers from 0 to 255. However, the word and double-word representations can be used to represent <strong>very</strong> large numbers. The maximum value that can be represented with a double-word is</p>
<pre><code>2^64 - 1 = 18,446,744,073,709,551,616 - 1 = 18,446,744,073,709,551,615

That is a 20-digit decimal number!!
</code></pre>
<hr />
<p><strong>Note:</strong> There are software tricks that can be used to represent numbers with more than 64-bits. We will not encounter such large numbers in any of the exercises in this book.</p>
<hr />
<p>The <strong>minimum</strong> number of bits required to a number can be found by computing
log<sub>2</sub>(number) and rounding up to the closest integer. If you do not know the logarithm (log) function that is fine, we will not need to use it extensively in this book. Another way is to find the smallest power of 2 that is <strong>greater</strong> than the given number - the exponent is the minimum number of bits required to represent that number. For example, the number 9 can be represented using 4 bits. Because 2<sup>4</sup> = 16 is the smallest power of 2 that is also greater than 9. Note that 2<sup>3</sup> is 8 and is smaller than 9.
What about the number 8? Well 2<sup>3</sup> is <strong>equal</strong> to 8 and so we cannot represent it with 3 bits because we need the smallest power of 2 that is <strong>greater</strong> than 8. We need 4 bits to represent the number 8.</p>
<p>Now that we know computers use fixed-width representations, the natural question is - what happens when a computation results in a number larger (or smaller) than the representable range?
When using 8-bit numbers, what result is generated when the computer is told to add 1 and 255?</p>
<p>The computation results in a overflow or carry. We will learn more about these concepts in this chapter and revisit them in the chapter on conditional flags.</p>
<h2 id="binary-arithmetic---addition"><a class="header" href="#binary-arithmetic---addition">Binary Arithmetic - Addition</a></h2>
<p>Binary addition and subtraction are done just like in decimal arithmetic. The basic rules remain the same.</p>
<pre><code> 0 + 0 = 0
 0 + 1 = 1
 1 + 0 = 1
 1 + 1 = 10
</code></pre>
<p>Here is an example of adding 0b101 (5) and 0b11 (3)</p>
<p>     1<sup>1</sup> 0<sup>1</sup> 1<br />
     0   1   1<br />
---------------<br />
1   0   0   0</p>
<p>Just like in decimal addition we add digits in the corresponding digits of the number from right to left. If the sum results in a carry (i.e. 1 + 1) then the carry is added to the next number. If the numbers are of dis-similar lengths then 0s are prefixed as required.</p>
<p>When binary arithmetic is performed in digital circuits there is a fixed-width for representing the numbers. So if the sum of the two numbers is larger than what can be represented, some special provision has to be made to indicate to the programmer that the result is incorrect.</p>
<p>For example, when adding the following <strong>4-bit numbers</strong> 0b1111 (15) and 0b0001 (1)</p>
<p>      1<sup>1</sup> 1<sup>1</sup> 1<sup>1</sup> 1<br />
      0   0   0   1<br />
      ---------------<br />
1 | 0   0   0   0</p>
<p>Since there are only 4-bits to represent the numbers the result can only hold 0b0000. The fifth and most significant bit is lost. Clearly some indication has to be provided to the programmer that the result is incomplete without the most significant bit. Computers usually do this using a special &quot;flag&quot; register called the Carry flag. The Carry flag is 1-bit wide and holds the result of the carry over of an addition. If the addition did not result in a carry then this flag is set to 0. If the addition results in a carry then the flag is set to 1. In the ARM architecture the carry flag (C) is part of the <a href="./arm_exec_state.html">PSTATE</a>.</p>
<h2 id="representing-negative-numbers"><a class="header" href="#representing-negative-numbers">Representing negative numbers</a></h2>
<p>There are multiple methods to represent negative numbers. One common method is to use the highest digit in a fixed-width number to represent the sign. The diagram below shows unsigned and signed 8-bit numbers. Signed and unsigned 8-bit numbers use (surprise!!) 8-bits to represent the number. In the diagram below those 8 bits are represented as empty boxes. Each digit of the 8-bit number is individually referred to by it's index. The index starts from 0 and goes till 7. Index 0 is also called the least significant bit (LSB) and index 7 is called the most significant bit.</p>
<p><img src="images/fixedWidth8bit.png" alt="8-bit fixed width" title="8-bit fixed width" /></p>
<p>Signed numbers use the most significant bit to represent the sign and the remaining bits to represent the magnitude of the number. For 8-bit signed number the bit at index 7 is used as the sign bit and bits 0-6 are used to represent the magnitude. For a N-bit number the bit at the N-1<sup>th</sup> index is the sign bit and the remaining bits are used to represent the magnitude.</p>
<p>For a 4-bit number the table below shows the binary and decimal equivalent when the number is interpreted as signed.</p>
<table><thead><tr><th>Sign &amp; Magnitude Representation</th><th>Decimal</th></tr></thead><tbody>
<tr><td>0b0000</td><td>0</td></tr>
<tr><td>0b0001</td><td>1</td></tr>
<tr><td>0b0010</td><td>2</td></tr>
<tr><td>0b0011</td><td>3</td></tr>
<tr><td>0b0100</td><td>4</td></tr>
<tr><td>0b0101</td><td>5</td></tr>
<tr><td>0b0110</td><td>6</td></tr>
<tr><td>0b0111</td><td>7</td></tr>
<tr><td>0b1000</td><td>-0</td></tr>
<tr><td>0b1001</td><td>-1</td></tr>
<tr><td>0b1010</td><td>-2</td></tr>
<tr><td>0b1011</td><td>-3</td></tr>
<tr><td>0b1100</td><td>-4</td></tr>
<tr><td>0b1101</td><td>-5</td></tr>
<tr><td>0b1110</td><td>-6</td></tr>
<tr><td>0b1111</td><td>-7</td></tr>
</tbody></table>
<p>While the above method can represent negative numbers it is not very efficient. First, notice that there are two representations for 0, namely - 0b0000 and 0b1000. Also, it would be difficult to implement logic circuits to do arithmetic with the above representation. Therefore, other representations are used. Two commonly used representations are 2's complement method and the 1's complement method. The ARM architecture and the following chapters use only 2's complement to represent signed integers. We will go over 2's complement representation below.</p>
<h3 id="twos-complement-representation"><a class="header" href="#twos-complement-representation">Two's complement representation</a></h3>
<p>In two's complement the most significant bit (MSB) of the number represents the sign of the number. The remaining bits represent the magnitude but are not interpreted literally. An N-bit two's complement representation can represent numbers in the range -2<sup>(N-1)</sup> to (2<sup>(N-1)</sup> - 1)</p>
<p>The table below shows 2's complement representation for a 4-bit number. Positive numbers in 2's complement start with 0 and the remaining bits represent the magnitude of the number. However, note that the maximum positive number that can be represented using in a 4-bit 2's complement representation is 0b0111 (i.e. 7). This corresponds to 2<sup>3</sup> - 1 = 7.</p>
<table><thead><tr><th>Two's complement</th><th>Decimal</th></tr></thead><tbody>
<tr><td>0b0000</td><td>0</td></tr>
<tr><td>0b0001</td><td>1</td></tr>
<tr><td>0b0010</td><td>2</td></tr>
<tr><td>0b0011</td><td>3</td></tr>
<tr><td>0b0100</td><td>4</td></tr>
<tr><td>0b0101</td><td>5</td></tr>
<tr><td>0b0110</td><td>6</td></tr>
<tr><td>0b0111</td><td>7</td></tr>
<tr><td>0b1111</td><td>-1</td></tr>
<tr><td>0b1110</td><td>-2</td></tr>
<tr><td>0b1101</td><td>-3</td></tr>
<tr><td>0b1100</td><td>-4</td></tr>
<tr><td>0b1011</td><td>-5</td></tr>
<tr><td>0b1010</td><td>-6</td></tr>
<tr><td>0b1001</td><td>-7</td></tr>
<tr><td>0b1000</td><td>-8</td></tr>
</tbody></table>
<p>To convert a negative decimal number to 2's complement we use the following steps.</p>
<ol>
<li>Write the number in binary, ignoring the sign</li>
<li>Invert the 0s and 1s in the number</li>
<li>Add 1 to the result of step 2.</li>
</ol>
<p>Note that step 2 is the same as performing the NOT logic operation on the number. We will learn that and other logic operations in a later section.</p>
<p>For example, let us convert -2 to two's complement binary representation.</p>
<ol>
<li>Number 2 in binary is 0b0010 (we will use a 4-bit binary representation)</li>
<li>NOT (0b0010) = 0b1101</li>
<li>Add 1 to the result: 0b1101 + 0b1 = 0b1110</li>
</ol>
<p>How do we convert a 2's complement number 0b1110 to decimal? The process is near identical.</p>
<ol>
<li>Note the sign bit</li>
<li>Invert the 0's and 1's in the number</li>
<li>Add 1 to the result of step 2. Convert the resulting binary number to decimal and affix appropriate sign.</li>
</ol>
<p>Let us reverse the processes we saw earlier and convert the 2's complement number 0b1110 to decimal.</p>
<ol>
<li>In this case the sign bit is 1, so it is a negative number.</li>
<li>We then compute NOT(0b1110) which is 0b0001. Adding 1 we get 0b0010.</li>
<li>Converting this to decimal we get 2. After affixing the sign we get -2.</li>
</ol>
<p>Here is another example - we convert -8 to two's complement binary.</p>
<ol>
<li>Number 8 is 0b1000</li>
<li>NOT(0b1000) = 0b0111</li>
<li>Add 1: 0b0111 + 0b1 = 0b1000</li>
</ol>
<hr />
<p>Note:</p>
<p>When writing numbers in binary there is no indication if the number is a signed 2's complement number or an unsigned number. So 0b1110 is both -2 (if interpreted as 2's complement signed number) as well as 14 (if interpreted as unsigned). The context in which the number is used determines whether it will be considered signed or unsigned.</p>
<hr />
<p>Let us try one more example. This time we will try to represent the number -9 as a 4-bit 2's complement number. If you have been following along so far you may wonder how this is possible. The smallest number that can be represented with 4-bit 2's complement is -2<sup>(4-1)</sup> = -2<sup>3</sup> = -8. We are actually going to show how this will not work.</p>
<ol>
<li>Number 9 is 0b1001</li>
<li>NOT(0b1001) = 0b0110</li>
<li>0b0110 + 0b1 = 0b0111</li>
</ol>
<p>The answer we get is a positive number since the MSB is 0. So clearly it is wrong. Since we know the answer should be a negative number can we &quot;fix&quot; things by pre-fixing a 1 to it? So what about 0b10111?</p>
<p>But that is 5 bits not 4. Let us see if this represents -9 in a 5-bit 2's complement interpretation. Converting 0b10111 2's complement number to decimal:</p>
<ol>
<li>Sign is negative</li>
<li>NOT(0b10111) = 0b01000</li>
<li>0b01000 + 0b1 = 0b01001</li>
</ol>
<p>0b01001 in decimal is 9. Affix the sign and we get -9!!</p>
<p>So if there were no limitation due to fixed width the 2's complement representation can be used to represent arbitrarily large or small integers. <strong>But in practice all arithmetic done using computers have fixed-width representation.</strong> </p>
<hr />
<p><strong>Some additional magic:</strong></p>
<p>Let us consider a 4-bit 2's complement number 0b1001. One other way to convert it to decimal is</p>
<ol>
<li>Compute its decimal value as though it is unsigned. In this case, 0b1001 is 9</li>
<li>Subtract it from 2<sup>4</sup>. So 9 - 2<sup>4</sup> = 9 - 16 = -7.</li>
</ol>
<p>Check the table of 2's complement above and you can see that -7 in 2's complement representation is 0b101.</p>
<p><strong>This works only for negative numbers.</strong> So, to convert any N-bit 2's complement number to decimal you can first treat it is unsigned and compute the decimal value. Subtract that decimal value from 2<sup>N</sup> to get the answer.</p>
<hr />
<h3 id="sign-extension-and-zero-extension"><a class="header" href="#sign-extension-and-zero-extension">Sign-extension and Zero-extension</a></h3>
<p>Here is another titbit about 2's complement representation. Consider a representation with arbitrary width:</p>
<ul>
<li>For positive numbers the leading number of zeros do not matter. So 0b0010 is the same as 0b00010 and 0b00000010 (all are 2)</li>
<li>For negative numbers the leading number of ones do not matter. So 0b1110 is the same as 0b11110 and 0b11111110 (all are -2)</li>
</ul>
<p>The numbers 0b1110, 0b11110, and 0b11111110 all have 1 as the MSB. So in 2's complement representation they are negative numbers. If we invert the numbers and add 1 we will get 0b0010, 0b00010 and 0b000000010. This gives us -2.</p>
<p>So if we want to convert a 4-bit 2's complement number to a larger fixed-width representation all we have to do is to replicate the sign bits the appropriate number of times. Replicating the sign bit to expand a fixed-width number is called <strong>sign-extension</strong>. The tables below show a positive and a negative number in 2's complement representation of different widths.</p>
<table><thead><tr><th align="right">Two's complement</th><th>Decimal number -2</th></tr></thead><tbody>
<tr><td align="right">0b1110</td><td>4-bit</td></tr>
<tr><td align="right">0b11111110</td><td>8-bit</td></tr>
<tr><td align="right">0b1111111111111110</td><td>16-bit</td></tr>
</tbody></table>
<table><thead><tr><th align="right">Two's complement</th><th>Decimal number 4</th></tr></thead><tbody>
<tr><td align="right">0b0100</td><td>4-bit</td></tr>
<tr><td align="right">0b00000100</td><td>8-bit</td></tr>
<tr><td align="right">0b0000000000000100</td><td>16-bit</td></tr>
</tbody></table>
<p>When working with signed numbers, most of the time, we want to sign-extend when expanding to a larger fixed-width representation. Occasionally there may be times when we want to take a signed or unsigned number and get a higher width number by just prefixing zeros. That is called <strong>zero-extension</strong>.
In the later sections of this book, when we start programming, we will see how sign- and zero-extensions are used.</p>
<h2 id="binary-arithmetic-with-twos-complement-numbers"><a class="header" href="#binary-arithmetic-with-twos-complement-numbers">Binary Arithmetic With Two's-Complement Numbers</a></h2>
<p>Addition with 2's complement numbers works just like adding unsigned numbers. Any carry from the sign bits is thrown away. Below is an example of adding 5 and -2 (both numbers are 4-bit wide).</p>
<p>      0<sup>1</sup> 1 0 1  (5)<br>
      1   1 1 0  (-2)<br>
      ------------<br>
<s>1</s> | 0   0 1 1  (3)</p>
<p>To <strong>subtract</strong> a number from another, say A - B, we take the 2's complement of he second number (B) and <strong>add</strong> it to the first. Here are a few examples of subtraction</p>
<hr />
<p><strong>Example 1:</strong> Lets try 3 - 2<br> <br>
0b0011 - 0b0010<br> <br> 
Taking two's complement of 2 we get: 0b0011 + 0b1110<br>
Adding the two numbers we get 0b0001 (carry is thrown away)</p>
<p>Now when we say the &quot;carry is thrown away&quot; what we mean is that the carry is ignored when performing signed addition or subtraction. The carry flag will still be set but it can be ignored by the programmer. For signed addition and subtraction the carry flag does not hold any significance.</p>
<hr />
<p><strong>Example 2:</strong> This method works regardless of the sign of the two numbers. For example...</p>
<p>3 - (-3) = 6<br> </p>
<p>0b0011 - 0b1101 (note the -3 in 2's complement is 0b1101)<br>
Taking 2's complement of -3 we get: 0b0011 + 0b0011<br>
Adding the two numbers: 0b0011 + 0b0011 = 0b0110</p>
<hr />
<h3 id="overflow"><a class="header" href="#overflow">Overflow</a></h3>
<p>What if the result of an operation is too large or too small to be represented using 4-bits. For example, continuing with 4-bit numbers, if we try to subtract -8 from 2 we get 2 - (-8) = 10. But 10 is too large to be represented using 4-bit two's complement representation. The detailed version of this subtraction is below.</p>
<p><strong>Example:</strong> -1 + (-8) = -9 <br>
Which is 0b1111 + 0b1000 <br>
After addition we get 0b0111.</p>
<p>But, 0b0111 is 7 and the answer we expect is -9. So this is clearly wrong. However, -9 cannot be represented with a 4-bit fixed width number. In this case, the overflow flag is set to indicate to the programmer that the result is too large. In the ARM architecture the overflow flag (O) is part of the <a href="./arm_exec_state.html">PSTATE</a>.</p>
<h2 id="what-we-learned"><a class="header" href="#what-we-learned">What we learned</a></h2>
<ol>
<li>Binary representation of unsigned numbers</li>
<li>Binary numbers represented with fixed-width</li>
<li>Two's complement representation of signed numbers</li>
<li>Binary arithmetic - addition and subtraction</li>
<li>Carry and overflow</li>
</ol>
<p>Note that the carry flag is relevant for unsigned operations and the overflow flag is relevant for signed operations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started-with-arm-aarch64-assembly"><a class="header" href="#getting-started-with-arm-aarch64-assembly">Getting Started With Arm AArch64 Assembly</a></h1>
<h2 id="assembly-instruction-encoding"><a class="header" href="#assembly-instruction-encoding">Assembly Instruction Encoding</a></h2>
<p>The Arm Architecture defines both 64- and 32-bit architectures. In this book we will focus on the 64-bit architecture which is called AArch64.</p>
<p>At a high level, micro-processors can be described as machines that execute a set of specifically assigned instructions. These instructions are coded/written by a programmer and are called programs (or applications, apps etc). The set of instructions that the micro-processor understands is defined in it's instruction set architecture (ISA).</p>
<p>Instructions are stored in memory and the microprocessor reads instruction from memory and executes them. The processor executes instructions one after another in the order specified by the programmer.</p>
<p>All instructions in the ISA are 32-bits long. This means that when a program compiled to execute on the ARM architecture is stored in memory, every instruction will take 8 bytes of memory. The encoding for the instructions are unique and so each instruction, such as add, subtract, multiply divide, branch etc, will have a distinct bit pattern that identifies it. The ARM architecture reference manual (ARM) lists all of the instructions available in the ARM ISA along with details of each instruction and its encoding.</p>
<p>For example, the encoding shown below, taken from the ARM ARM shows the encoding for an integer Add instruction. This instruction adds an immediate integer value (imm12) to the integer value stored in a selected register (Rn) and saves the result in a selected  destination register (Rd). Note that an immediate value, in this context, means that the value is encoded with the instruction.</p>
<p><img src="images/Add_Imm_Encoding.jpg" alt="ADD imm encoding" title="ADD imm encoding" /></p>
<p>In the figure above, notice that the bits are numbered from 0 to 31. Starting the count from 0 is quite common in computer science and engineering. </p>
<p>Lets take a look at each part of the encoding. For this specific instruction, bit 31 - labeled as 'sf' - determines whether the instruction is operating on 32- bits (when sf is 0) or 64-bits of data (when sf is 1).</p>
<p>The twelve bits in the index range 10-21 hold the immediate value. The register numbers to use are encoded in bits 0-4 (Rd) and 5-9 (Rn). In the architecture, programmers are provided 32 general purpose registers to use. They can be encoded using 5 bits (i.e. 2<sup>5</sup> = 32). The S bit (29) indicates whether the instruction will set condition codes. Since the S bit is 0 in this encoding, it means this instruction will not set condition codes. We will discuss condition codes in more detail later in this book. </p>
<p>Let us say we wish to add the value 323 to the contents of register R5 and place the results in the register R10. The encoding for that operation using an Add immediate instruction in AArch64 will look like below. </p>
<p><img src="images/Add_Imm_Encoding2.jpg" alt="Populated ADD imm encoding" title="Populated ADD imm encoding" /></p>
<p>Note that we have set sf=0 so this instruction will be a 32-bit add. We have set the 12-bits of imm12 to the value 323. The values of Rn and Rd have been set to 5 and 10 respectively. The sh bit, which we have not discussed so far, has been set to 0. In hexadecimal format this bit pattern is <strong>0x11050CAA</strong>.</p>
<p>Clearly, it would be very difficult for programmers to write entire programs as hexadecimal digits. Thankfully that is not necessary. Programs can be written in a more convenient, human readable, way using Assembly Language. The same operation can be written in assembly code as: </p>
<blockquote>
<p>ADD W10, W0, #323</p>
</blockquote>
<p>The one bit of detail we have not covered is the function of the sh bit. When this bit is set to 0 the imm12 value is zero extended. If sh is set to 1 the imm12 value is left-shifted by 12 bits and then zero extended. For now, it does not matter if you do not understand the function of the sh bit. </p>
<hr />
<p><strong>NOTE</strong></p>
<p>Zero extension is covered in the chapter on Integer Binary Arithmetic</p>
<hr />
<p>Programs can be written in assembly language and that is a more human friendly form compared to encoding everything in hex. But since the processor only understands encoded instructions, a special application called <strong>Assembler</strong> is used to convert assembly programs into hexadecimal encoding.</p>
<p>Programming languages such as C, C++, Python etc allow programmers to write code at an even higher level of abstraction. Code written in high-level languages are first converted to Assembly language. This is done using an application called a <strong>Compiler</strong>. Once the program has been compiled another program called <strong>Assembler</strong> is used to convert the assembly code into instruction encoding.</p>
<h2 id="registers"><a class="header" href="#registers">Registers</a></h2>
<p>The architecture provides a a number of registers that can be used by programmers for various purposes. In this chapter we will give you an overview of the portions of the architecture that are relevant to application programmers. As we cover more ground in later chapters we will gradually introduce the other portions of AArch64.</p>
<p>Instructions in microprocessors operate on data that is stored in memory. However, Arm is a RISC architecture. This means that the instructions do not directly perform computation on <strong>data in memory</strong>. The data has to be first loaded into one of 31 general purpose registers in the processor. These registers can hold either 64-bit or 32-bit data. When accessed as 64-bit values the registers are named X0-X30 (counting from 0 remember, so 31 registers). When accessed as 32-bit values the registers are names W0-W30. </p>
<p>These registers are called &quot;general purpose&quot; because they can be used by the programmer to store any data he/she desires. The X30 register alone, by convention, is also used as a procedure call link register. This register is used to specify the address the processor should return to after completing a function. We will discuss how to use this register and the BL instruction in the section on Function Calls.</p>
<p>It is important to note that the 32-bit and the 64-bit register names are labels to access the same set of registers. The 32-bit names access the lower 32 bits (i.e. 0-31) and the 64-bit names access all the register bits (0-63).</p>
<p>Like the general purpose registers, which can be used by integer and memory instructions, there is another set of <strong>32</strong> registers that can be used with SIMD and floating-point instructions. These registers are named V0-V31. We will use them in the chapter on floating-point and SIMD instructions.</p>
<p>In addition to the above, programmers have access to the stack register (SP). The lower 32-bits of this register can be accessed using the name WSP. The stack register holds the memory address of the current <em>stack pointer</em>. The Stack is a special area in memory and will be discussed in detail in later sections.</p>
<p>Finally there is the program control register. This register holds the memory address of the <em>current instruction</em>. In AArch64, cannot be directly modified by the programmer. It is updated by the processor when a branch/call instruction is executed and on exception return. </p>
<p>That was a lot of information and it is OK if you do not understand all of this yet. We will discuss the usage of all the above registers, and a few more, in more detail in each section.</p>
<p>The main point to understand in this section is that the processor cannot operate directly on data in memory. Values have to be loaded into <em>storage buffers</em> called registers. Integer instructions such as ADD, SUB etc operate on general purpose registers and can store the result of their operation also in a such a register.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory-instructions"><a class="header" href="#memory-instructions">Memory Instructions</a></h1>
<p>Finally, lets start with some AArch64 assembly. Memory instructions can be used to transfer data from memory into registers. Memory is byte addressed, meaning that every byte (8 bits) of memory has a unique address that is used to identify the location.</p>
<p>In most computer/embedded systems memory is located in a chip that is separate from the CPU. Memory is connected to the CPU via a bus or interconnect. To load a byte of memory into a register we can use this instruction</p>
<pre><code class="language-armasm">  LDRB W10, [X1], #0
</code></pre>
<p>This form of the load instruction uses the <strong>post-indexed</strong> addressing mode. This instruction performs two operations:</p>
<ol>
<li>Load 1 byte of memory from memory, into the specified destination register</li>
<li>Update the address in the base register</li>
</ol>
<p>The memory address of the data is provided using a register, in this case X1. This instruction fetches 1 byte of data from memory at the address specified in X1. That byte is sign extended to 32 bits and stored in W10.</p>
<p>The offset, specified as an immediate value is added to the base address (by the processor) and the result is stored in the register X1.</p>
<p>In this specific example the immediate value is 0. Therefore the base address in X1 will remain unchanged after the instruction is executed.</p>
<p>The LDRB instruction can also be used with <strong>pre-indexed</strong> addressing mode like this</p>
<pre><code class="language-armasm">  LDRB W10, [X1, #0]!
</code></pre>
<p>In this addressing mode the data address is the sum of X1 and the immediate offset. One byte, at that address, is loaded (sign extended) into the destination register (W10) and the base register (X1) is also updated with the computed address.</p>
<p>Below is an example of a <strong>post-indexed</strong> store instruction. This instruction stores 1 byte from the register W10 into the memory location contained in register X1.</p>
<pre><code class="language-armasm">  STRB W10, [X1], #0
</code></pre>
<p>Both LDRB and STRB instructions have multiple <em>addressing modes</em> (i.e. ways of specifying the memory address). We will eventually learn all of those modes. But now let us write a small program with two instructions that we know so far.</p>
<h2 id="copying-data"><a class="header" href="#copying-data">Copying Data</a></h2>
<p>To learn how to load/store data from/to memory we will write a few assembly programs. The first program, below, will copy the words &quot;Hello&quot; from one location in memory to another location. The program code and instructions to compile and run it are in the file memory_instructions/ex1a_solution.s</p>
<p>As a learning exercise, it would be best if you could type out the program into the specified location in the file memory/ex1a.s and try running it yourself. You can do this using any text editor.</p>
<p>For all exercises in this book two assembly (.s) files are provided - a template file and a solution file. You should read the material in the book and attempt to write the code yourself for each exercise. Look at the solution only if you are unable to get your program to work correctly. The assembly files have clearly marked sections where you can write your code.</p>
<p>For the first exercise, to get you started, we will discuss the code in detail. Open ex1a.s and type the code below into the appropriate location.</p>
<pre><code class="language-armasm">    // Your code starts here

    ldrb w4, [x0, #0] // load H
    strb w4, [x1, #0] // store H

    ldrb w4, [x0, #1] // load e
    strb w4, [x1, #1] // store e

    ldrb w4, [x0, #2] // load l
    strb w4, [x1, #2] // store l

    ldrb w4, [x0, #3] // load l
    strb w4, [x1, #3] // store l

    ldrb w4, [x0, #4] // load o
    strb w4, [x1, #4] // store o

    // Your code ends here


</code></pre>
<p>In ex1.s we have provided set up code code that will store the text &quot;Hello&quot; into one location in memory and &quot;Howdy&quot; in another location in memory. The setup also provides the start address of &quot;Hello&quot;  and the start address of &quot;Howdy&quot;. The objective of this exercise is to copy the contents of memory starting at X0 into memory location starting at X1.</p>
<p>So how does this program work. Actually, it is pretty simple. In a computer every character or letter is stored in a byte of data (8-bits, remember) in a format called ASCII. There are other formats for storing text but in this book we will use only ASCII since it is easy to deal with. The word Hello has five letters and therefore it takes five bytes of data to store it in memory. In ASCII encoding numbers are used to represent English alphabets, numbers, and some symbols.</p>
<p>In ex1.s the register X0 has been pre-loaded with the memory address of the first byte of the string. This is the memory address of the character corresponding to the letter &quot;H&quot;. The destination address - location where the string should be copied to - is provided in X1. Before the start of the program the address starting at X0 contains the word &quot;Hello&quot; in consecutive memory locations (X0, X0+1...X0+4). Just for fun we have stored the word &quot;Howdy&quot; starting at the address in X1.</p>
<p>The code copies one character at a time from the address starting at X0 to the address at X1. Each character of the string Hello is 1 byte in size. So to copy the entire string we have to copy 5 bytes. Each character is stored in continuous locations of memory. In this program, <strong>H</strong> starts at memory address 0x800ac, <strong>e</strong> is at 0x800ad, and <strong>l</strong> at 0x800ae and so on. <strong>Note:</strong> Each character is 1 byte in size. </p>
<p>The solution provided uses the base plus immediate offset addressing mode (aka immediate offset mode). In this mode the address of the memory operation is computed by adding the specified base register with a immediate value. The immediate value is also provided by the programmer.</p>
<p>The first instruction in the solution above is:</p>
<pre><code class="language-armasm">  ldrb w4, [x0, #0]
</code></pre>
<p>This is a Load byte instruction that loads 1 byte of data from memory into the register W4. The address of the memory location to load the data from is computed by adding 0 to the base register X0. After execution of this instruction the memory contents of the byte starting at address (X0 + 1) will be loaded into the register W4. The value of register X0 will remain unchanged. Similarly the store instruction</p>
<pre><code class="language-armasm">  strb w4, [x1, #0]
</code></pre>
<p>Stores one byte of data from W4 into the memory location (X1+0).</p>
<p>To copy the full string we load the value of each character into W4 and store it in the appropriate memory location.</p>
<hr />
<p><strong>NOTE:</strong> Exercises, in this and other sections,  have some supporting code and assembly directives. You should not modify these lines in the file. The supporting code is for the following:</p>
<ol>
<li>Place the string Hello in some address in memory.</li>
<li>Reserve some space in memory for you to copy the string</li>
<li>Provide the address of the first character of Hello (i.e. H) in the register X1</li>
<li>Provide the address of the destination in address X2</li>
<li>The strings in at X1 and X2 are printed before and after your code is executed so that you can check if the copying has been done correctly.</li>
</ol>
<p>Later in this book we will discuss how to print strings.</p>
<hr />
<h3 id="addressing-modes"><a class="header" href="#addressing-modes">Addressing Modes</a></h3>
<p>In ex_1a.s we introduced the immediate offset addressing mode. The Arm architecture has other addressing modes to specify addresses in load and store instructions. In the rest of this section we will take  look at these modes.</p>
<p>Exercises ex_1b.s to ex_1d.s are similar to ex_1a.s. The objective is to accomplish the same result by using different addressing modes. Though the solutions for these exercises are provided we <strong>strongly</strong> encourage you to read the rest of this section and try to write the programs yourself. Consult the solution if you are unable to solve the exercise in reasonable time (say in one day).</p>
<p><strong>Post-indexed Addressing Mode</strong></p>
<p>Example:</p>
<pre><code class="language-armasm">  ldrb w4, [x0], #1
</code></pre>
<p>This instruction performs two operations</p>
<ol>
<li>It loads the value from the memory address in the base register.</li>
<li>It adds the base register with the provided offset and stores that result into the base register.</li>
</ol>
<p>In the example above, the value contained in memory location x0 is loaded into register w4. In addition x0 is increased by 1.</p>
<p>Try to write the code for exercise ex_1b.s using post-indexed addressing mode.</p>
<p><strong>Pre-indexed Addressing Mode</strong></p>
<p>In this addressing mode the address is the sum of a base register and a specified offset value. The computed address is also stored back in the address register.</p>
<p>Example:</p>
<pre><code class="language-armasm">  ldrb w4, [x0, #1]!
</code></pre>
<p>In the example, the memory address is computed as the sum of x0 and 1. The byte in that location is loaded into register w4. The computed address is also stored in register x0.</p>
<p>Try to write the code for exercise ex_1c.s using pre-indexed addressing mode. Hint - you can load (and store) the first character using a different addressing mode.</p>
<p><strong>Base Plus Register Offset Addressing Mode</strong></p>
<p>In this mode the address is the sum of the base register and an offset that is contained in another register.</p>
<p>Example:</p>
<pre><code class="language-armasm">  ldrb w4, [x0, x2]
</code></pre>
<p>The address for this load instruction is computed by adding the base register x0 with the register x2.</p>
<p>Try to write the code for exercise ex_1d.s using register offset addressing mode. Hint - you can save an immediate value into a register using the <strong>mov</strong> instruction like this</p>
<pre><code class="language-armasm">  mov  x2, #0
</code></pre>
<p>Note that in all the above addressing modes any register that is used in address computation is a 64-bit X register.</p>
<h2 id="half-word-word-and-double-word-memory-operations"><a class="header" href="#half-word-word-and-double-word-memory-operations">Half-word, Word, and Double-Word Memory Operations</a></h2>
<p>So far we have looked at load and store instructions that operate on one byte of memory. There are memory instructions that operate on larger chunks of memory, namely - half-word, word, and double-word.</p>
<p>What are these terms and what sizes do they indicate?</p>
<p>We already know that data in computers are represented as bits. Bits can take one of two values - 0 and 1. A group of 8-bits is called a byte. Furthermore, every byte of memory has its own identifier - a memory address that distinguishes each byte from other bytes in memory.</p>
<p>A word is a group of bytes. However, unlike byte which is always 8 bits, the size of a word is not a standard across different architectures. In the Arm architecture the size of a word is 4 bytes (i.e. 32 bits). A half-word is 2 bytes and a double-word is 8 bytes.</p>
<p>The architecture has load/store instructions that can load half-word, word, and double-word from/to memory.</p>
<p>Load/store double-word example:</p>
<pre><code class="language-armasm">	ldr x4, [x0], #8
	str x4, [x1], #8
</code></pre>
<p>This instruction copies 64-bits of data (8 bytes) from the memory. The address of the first of these 8 bytes is contained in the register x0. Notice that the destination register is an <strong>x</strong> register so that we can accommodate the 8 bytes being read. Since we have used post-indexed addressing the address contained in x0 will also be incremented by 8.</p>
<p>Load/store word example:</p>
<pre><code class="language-armasm">    ldr w4, [x0], #4
    str w4, [x1], #4
</code></pre>
<p>The <strong>ldr</strong> and <strong>str</strong> instructions load a half-word from memory (2 bytes). The examples above show post-indexed forms of the load instruction.</p>
<p>Load/store half-word example:</p>
<pre><code class="language-armasm">	ldrh w4, [x0], #2
	strh w4, [x1], #2
</code></pre>
<p>The <strong>ldrh</strong> and <strong>strh</strong> instructions load a half-word from memory (2 bytes). The examples above show post-indexed forms of the load instruction.</p>
<p><strong>Note:</strong> The Arm Architecture Reference Manual has detailed description of all the instructions discussed in this book. It is a useful reference to have when you attempt to write your own code for the exercises.</p>
<h2 id="copy-memory-using-operations-of-different-sizes"><a class="header" href="#copy-memory-using-operations-of-different-sizes">Copy memory using operations of different sizes</a></h2>
<p>Now for a small challenge. In file <em>exercises/memory_instructions/ex_1e.s</em> the text &quot;Welcome To Arm Assembly World&quot; has been stored in memory and the address of the first byte of this string is placed in x0. The register x1 is loaded with the address of a memory location that you may write to. Using any combination of word, half-word, double-word and byte operations copy the text pointed to by x0 to the location pointed to by x1.</p>
<details>
  <summary>The solution to this exercise is below (also in exercises/memory_instructions/ex_1e_solution.s)</summary>
<pre><code class="language-armasm">    // Your code starts here

    ldr x4, [x0], #8 // copy &quot;Welcome &quot;
    str x4, [x1], #8 // store &quot;Welcome &quot;

    ldrh w4, [x0], #2 // copy &quot;To&quot;
    strh w4, [x1], #2 // store &quot;To&quot;

    ldr w4, [x0], #4 // copy &quot; Arm&quot;
    str w4, [x1], #4 // store &quot; Arm&quot;

    ldp x3, x4, [x0] // copy &quot; Assembly World&quot;
    stp x3, x4, [x1] // store &quot; Assembly World&quot;

    // Your code ends here
</code></pre>
<p><strong>Note:</strong> The <strong>ldp</strong> (Load pair) and <strong>stp</strong> (Store pair) instructions in the above example loads/stores a pair of 64-bit <strong>x</strong> registers from memory. These instructions can therefore load/store 16 bytes (128 bits) of data at a time.  In this example, we have used the immediate offset addressing mode. The pair load/store instructions also support immediate offset, pre-indexed and post-indexed addressing modes.</p>
</details>
<h2 id="copying-data-using-a-loop"><a class="header" href="#copying-data-using-a-loop">Copying data using a loop</a></h2>
<p>So far we have used multiple load and store instructions to copy data. For instance, in ex_1a.s we used five load and five store instructions to copy the letters &quot;Hello&quot; from one location to another.</p>
<p>In this section we will see how to do the same using a loop and fewer load and store instructions instructions. The code in this section can be found in the file <em>exercises/memory_instructions/ex_1f_solution.s</em>. After reading the explanation in this section we recommend readers try to replicate this program using the file <em>exercises/memory_instructions/ex_1f.s</em>.</p>
<p>Our objective is to copy a string of unknown length from one location to another. In this exercise, that string is &quot;Hello&quot; and it has 5 letters. But we want to write a generic program that will work even if the string were longer or shorter. Strings are stored in memory using a format called ASCII. There are other formats to represent alphabets in computers but this one is one of the simplest and most popular - though it does have limitations.</p>
<p>The characters comprising a string are stored in contiguous locations in memory. Also, at the end of every string a special character (string termination) - namely 0 - is stored to indicate the end of the string. If the special character were nor present there would be no way to tell when a string has ended.</p>
<p>The code listing below shows the program. You will notice that there are two labels that are clearly not assembly instructions. Labels such as &quot;find_len_start:&quot; and &quot;copy_loop_start:&quot; act as markers that can be used by assembly instructions to refer to the memory address of instructions or data.</p>
<pre><code class="language-armasm">1.  mov  x2, #0
2.  ldrb w5, [x0, x2]
3.  cbz  w5, skip_to_copy
find_len_start:
4.  add  x2, x2, #0x1
5.  ldrb w5, [x0, x2]
6.  cbnz w5, find_len_start

skip_to_copy:
7.   mov  x3, #0x0
copy_loop_start:
8.   ldrb w4, [x0, x3]
9.   strb w4, [x1, x3]
10.  add  x3, x3, #0x1
11.  cmp  w2, w3
12.  b.gt copy_loop_start
</code></pre>
<p>The first section of the program, comprising of instructions 1-4, is to find the length of the string. We use x2 to store the count and initialize its value to zero using the <strong>mov</strong> instruction. This mov instruction places an immediate value into a register. There is also a variant that can be used to copy the contents of one register into another.</p>
<p>This instruction is followed by a label <strong>find_len_start:</strong>. Labels are used to mark points in the code that can be referred to from other places in the code. Following the label, we load the first character into w5 using an ldrb instruction. This should be familiar to you from previous sections.</p>
<p>The next instruction is a new one that we have not seen so far.</p>
<pre><code class="language-armasm">   cbz  w5, skip_to_copy
</code></pre>
<p>CBZ is the &quot;compare and branch if zero&quot; instruction. This instruction checks if the value of a specified register is 0. If it is then processor  will jump to the instruction at the specified label. If not the processor continues to the next instruction.</p>
<p>Instruction 3 compares if the value in w5 is 0. If it is zero then the processor will jump to the label skip_to_copy and will start executing instructions from instruction 4. Why do we use cbz? If the first character read is 0 then that means the string is a blank string with length 0. So we do not need to count the number of characters in that string. We can skip the code that is counting the number of characters and jump to the part that will copy the characters.</p>
<p>After the cbz instruction we have a label named &quot;find_len_start:&quot;. Observe that the labels have to end with a colon symbol. But when used as part of an instruction, the colon is omitted. Labels in code refer to the address of the instruction immediately below them. The label find_len_start is a marker to the address of instruction 4. Other instructions in the program can refer to instruction 4 using this label. This is also useful if, later in the program, we want the CPU to start executing at instruction 4.</p>
<p>The code comprising of instructions 4-6 is a loop. The CPU will execute them one after another and when it reaches instruction 6 - cnbz - it will either go on to instruction 7 or back to instruction 4. The cnbz instruction checks if a given register is <strong>not</strong> zero. If the instruction contains a value other than zero then the code jumps to the instruction with the specified label. In this case that is instruction 4.</p>
<p>This loop (4-6) performs the task of finding the length of the given string. We store the count of the number of characters in register x2. We have previously checked that the first character is not 0 (i.e. end of string). Therefore, the string we have to copy has at least one character. In the loop the count is increased by 1 using an add instruction. The next instruction loads one byte of data from the address contained in [x0, x2]. The base address of the string is in register x0. When we add x2 to x0 we get the address of the second character of the string (because x2 is 1). The cbnz instruction checks if the loaded value is <strong>not</strong> zero. If the loaded value is not zero then the CPU will jump back to instruction 4 and start execution from there.</p>
<p>The loop to count the number of characters will continue to execute until character 0 is loaded - indicating a end of string. At that instance the cbnz instruction will find the loaded value is 0 and so the CPU will not jump to find_len_start. Instead it will move on to the next instruction.</p>
<p>After counting the number of characters in the string we copy the string to a location specified by the address in x1. We first initialize register x3 to 0 using a mov instruction. We will use x3 to track the current character being copied. It will also aid in computing the address of that character. Copying the string is also done using a loop comprising of instructions 8-12. The start of the loop is labelled copy_loop_start.</p>
<p>The first instruction in the loop loads a byte from the string starting at x0 and the next instruction stores that value into a memory location starting at x1. Both instructions use a base plus register addressing with x0/x1 as the base and x3 as the offset  register. The next instruction increments the x3 register. We are using the x3 register as the offset from the base and also to count the number of bytes that have been copied.</p>
<p>This is followed by a compare instruction to check if the value in x2 is greater than x3.</p>
<pre><code class="language-armasm">  cmp w2, w3
</code></pre>
<p>The compare instruction compares the value in x2 with the value in x3 and sets appropriate flags in the flag register. The exact operation is described in the <a href="https://developer.arm.com/documentation/ddi0487/ga">Arm Architecture Reference Manual, Armv8, for Armv8-A architecture profile</a>. The manual section C6.2 provides an alphabetical list of AArch64 base instructions. There are two entries for the CMP instruction in that list. The first one, titled &quot;CMP(immediate)&quot; is the CMP instruction when it is used with an immediate operand. The second one, titled &quot;CMP(shifted register)&quot; provides details of the CMP instruction when used with registers. In this program we are using the register version of the instruction.</p>
<p>Why is the cmp instruction using registers w2 and w3 instead of x2 and x3? Remember that in AArch64 integer registers can be referred to in 64-bit or 32-bit form. The x0-x30 register names refer to 64-bit register names and w0-w30 register names refer to the lower 32 bits of the X registers. So the <strong>cmp</strong> instruction is operating on 32-bit registers. In this program the registers x2 and x3 hold the count of number of characters. It is unlikely we will have strings with lengths in excess of 32-bits. Therefore we can use the corresponding &quot;W&quot; names to <strong>read</strong> these registers.</p>
<hr />
<p><strong>Note:</strong></p>
<p>If the string length is larger 2^32-1 (4294967295) then we cannot use W registers instead of X registers. Since that number is reasonably large, for this exercise, we can assume we will never encounter longer strings. Whenever a register is used as part of an address we should always use the X form of the register. This is because all memory addresses in AArch64 are 64-bit wide. That is why the load and store instructions use X registers for the address.</p>
<hr />
<p>The instruction that follows cmp is a &quot;branch if greater than&quot; instruction. The cmp instruction has set the appropriate PFLAGS. The b.gt instruction uses the information in the flags to determine if the CPU should branch to the specified label or continue to the next instruction. The instruction will branch to copy_loop_start if the compare results show that w2 is greater than w3.</p>
<pre><code class="language-armasm">  b.gt	copy_loop_start
</code></pre>
<p>Thus, the second loop executes instructions 8-12 until the value in register w3 becomes greater than the value in register w2 (length of the string). The characters in the string beginning at address in X0 are copied into the address beginning at the address in X1.</p>
<h2 id="memory-instructions-challenge-assignments"><a class="header" href="#memory-instructions-challenge-assignments">Memory Instructions Challenge Assignments</a></h2>
<h2 id="exercise-ex_2a"><a class="header" href="#exercise-ex_2a">Exercise ex_2a</a></h2>
<p>The file ex_2a.s provided in the exercise section is to be used for this challenge. The objective of this exercise is to copy a string from one memory location to another but the new string should be a reversed version of the original. So if the original string was &quot;Hello&quot; the new string should be &quot;olleH&quot;.</p>
<p>The address of the string to reverse is provided in the register x0. The memory address where the reversed string should be placed is provided in register x1. Sufficient memory has been provided to hold both strings.</p>
<p>Below is pseudo code to reverse the string. You can use this as a guide to write the assembly code.</p>
<ol>
<li>Count the length of the string using a loop</li>
<li>Use two registers - one to count from 0 till end of string and another to count down from the end of string to 0.</li>
<li>Using the above two registers in a loop, copy bytes from the string at location x0 to the string at location x1.</li>
</ol>
<p>The solution for this exercise is provided in ex_2a.solution.s. We recommend that you try to write the program your self before looking at the solution.</p>
<h2 id="exercise-ex_2b"><a class="header" href="#exercise-ex_2b">Exercise ex_2b</a></h2>
<p>The file ex_2b.s provided in the exercise section is to be used for this challenge. The objective of this exercise is to reverse a string in-place. This means the string should not be copied to a new location but can be copied onto itself.</p>
<p>The address of the string to be reversed is in register x0. Below is the pseudo code for the program:</p>
<ol>
<li>Find the length of the string.</li>
<li>Use one register (any register, say X1) to count from 0 till the end of the string. Another register (X2) to count from the size of the string to 0.</li>
<li>Using the above registers in a loop. Load the characters from both offsets and store them into the appropriate location.</li>
</ol>
<p>Hint: You can use different forms of memory addressing including post-indexed.</p>
<p>The solution for this exercise is provided in ex_2b.solution.s. We recommend that you try to write the program your self before looking at the solution.</p>
<h2 id="what-we-learned-1"><a class="header" href="#what-we-learned-1">What we learned</a></h2>
<ol>
<li>Load and Store instructions of different sized - byte, half-word, word, and double</li>
<li>The following addressing modes: pre-indexed, post-indexed (imm and register variant), base plus offset (imm and register variant).</li>
<li>Compare and branch instructions</li>
<li>Labels in assembly</li>
<li>Loops in code</li>
</ol>
<hr />
<p><strong>NOTE:</strong> In Arm assembly language the different forms of mov instructions are aliases to other instructions. That means the instruction encoding of the mov instruction is the same as that for another Arm instruction. Both operations will yield the same result.</p>
<p>For example:</p>
<pre><code class="language-armasm">  mov x0, x2
</code></pre>
<p>The above instruction copies the value in x2 to x0. This instruction has the same encoding as an OR instruction shown below</p>
<pre><code class="language-armasm">  or x0, XZR, x2
</code></pre>
<p>If this does not makes sense to you right now, that is OK. Just know that both the example instructions above will copy the value stored in x2 to x0.</p>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="integer-instructions"><a class="header" href="#integer-instructions">Integer Instructions</a></h1>
<p>We have already used two arithmetic instructions - <strong>add</strong> and <strong>cmp</strong> - in the previous section. In this section we introduce a few more commonly used integer instructions. Like earlier, we will do this through a series of assembly programs. For some of the programs we have provided the explanation in pseudo code only. This is an opportunity for you to write the assembly program by yourself.</p>
<h2 id="sum-of-numbers-in-an-array"><a class="header" href="#sum-of-numbers-in-an-array">Sum of numbers in an array</a></h2>
<p>In this exercise we will add a set of numbers in a loop. We will also learn a new memory addressing method in the bargain.</p>
<p>In computer programming, arrays are data structures that consist of the same type of data stored in contiguous locations of memory. Examples of the type of data includes 8-bit integers, 16-bit integers, 32-bit integers etc. ASCII strings are arrays of 8-bit integers that have a special value that indicates the end of string. Arrays of other types do not have any end markers like strings. Therefore, the programmer should know the number of elements stored in the array so that they do not overshoot the array and access memory locations outside of it.</p>
<p><img src="images/array.png" alt="Array in memory" title="Array in memory" /></p>
<p>The figure above shows how the elements of an array appear in memory. In this example, each element is 4 bytes large. The start address of the array is in x4. Since the array elements are 4-bytes large, the address of the second element is [x4 + 4] and the one after that [x4 + 8] and so on. This array has N+1 elements and the address of the last element is [x4 + N]. Here N is just an example to show arrays can be of any length.</p>
<p>Arrays are a convenient way to store a list of the same type of object. When an operation is to be performed on all elements of a array it is typically done in a loop. Programmers can easily read/write to each item in the list by using the register + offset, pre-indexed, or post-indexed modes of addressing.</p>
<p>One common programming error is to access beyond the end of an array. The dotted region in the figure represents memory that is outside the array. Programmer should be careful to only access memory locations that are part of the program. Accessing memory outside the locations representing the program's data may not cause the program to crash always. But may cause subtle errors and crashes that are difficult to debug.</p>
<p>We will now look at a program that has 32-bit integers stored in an array. The program will add all the integers in the array and print their sum. Our program is organized as follows:</p>
<ul>
<li>The address of the first element of the array is stored in the register x4</li>
<li>The register w1 stores the number of elements in the array</li>
<li>The sum of the elements is stored in w0</li>
</ul>
<p>The address of the first element of the array is stored in the register x4. We will use the register x2 as the index for different values of the array. The relevant portion of the program is given below. The reader can try it out by typing this code in the file integer_instructions/sum.s</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make sum.elf
RUN_COMMAND: make run
</code></pre>
<p>The program code:</p>
<pre><code class="language-armasm">   // Your code starts here
    mov    x4, x0

   // Initialize sum to 0.
    mov    w0, 0

   // Iterate over elements of the array and add the value to result

   // Initialize index to 0. This register will hold the value of current element number
   mov    x2, 0
loop:
    // Load the value at current index
    ldr    w3, [x4, x2, lsl 2]

    // Add the value to sum
    add    w0, w0, w3

    // Increment the index
    add    x2, x2, 1

    // Check if we have iterated through all the elements of the array
    cmp    w1, w2

    // Branch back to beginning of loop if there are more elements
    bgt    loop

    // Your code ends here
</code></pre>
<p>One can add comments in the code by starting the line with the text &quot;//&quot;. Everything following in that line will be ignored when the program is assembled/compiled. In this program the explanation for every instruction is provided as comments. The load instruction in this program uses a slightly different form of memory addressing than the ones we have encountered so far. This addressing mode is the register + offset mode that we learnt in the section on Memory Instructions. The addressing mode allows the programmer to provide an optional operation that is to be performed on the offset register.</p>
<blockquote>
<p>ldr    w3, [x4, x2, lsl 2]</p>
</blockquote>
<p>To compute the address of the load, the offset register (x2) is left shifted by 2 and added to the x4 register.</p>
<blockquote>
<p>x4 + (x2 &lt;&lt; 2)</p>
</blockquote>
<p>Why do we left shift by 2? Every element in this array is 4 bytes large. The address of each element is offset from the base by the element's index number times 4. For example, for the 4th element in the array the offset from the begining of the array is 3 * 4 = 12 bytes. Remember that the first element of the array is at the 0th index and the fourth element is at index 3.</p>
<p>We track the index of the current element in register w2 and therefore we multiply that number by 4 to get the memory address offset. As we saw in the binary arithmetic section, multiplying by 4 is the same as left shifting by 2.</p>
<hr />
<p><strong>Extend operators in register+offset addressing:</strong></p>
<p>We used the LSL extend operator in this example. The register+offset addressing method has three other extend operators. These are:</p>
<ul>
<li>UXTW</li>
<li>SXTW</li>
<li>SXTX</li>
</ul>
<p>We will learn about these operators later in the book.</p>
<hr />
<h2 id="finding-the-maximum-number-in-an-array"><a class="header" href="#finding-the-maximum-number-in-an-array">Finding the maximum number in an array</a></h2>
<p>Here is a challenge for you. Write a program to find the maximum number in a given array of numbers. The file <em>exercises/integer_instructions/find_max.s</em> has the data set up and comments indicating where your code should be placed. Here is the information you need to write this program:</p>
<ul>
<li>The address of the first element in the array is stored in x0</li>
<li>The number of elements is in the array is in x1</li>
<li>The size of each element in the array is 1 word (4 bytes)</li>
<li>Store the number</li>
</ul>
<p>Can you write a program to find the maximum number in the array?</p>
<p>The assembly program can be written in multiple ways. It does not matter if your program is not identical to the solution as long as it finds the correct answer.</p>
<p><strong>csel</strong> is a new instruction that can be used as part of this exercise. This instruction checks the condition set by the previous instruction (could be a cmp instruction) and if the condition is true it copies the value of Wn to Wd. If the condition is false it copies the value in Wm to Wd.</p>
<pre><code class="language-armasm"> csel &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;, &lt;cond&gt;
</code></pre>
<p>The condition in the cond field can be one of the following (from <a href="https://developer.arm.com/documentation/ddi0487/ga">Arm ARM</a> C.1.2.4 Condition Code) :</p>
<table><thead><tr><th>Mnemonic</th><th>Meaning (integer)</th><th>Condition Flags</th></tr></thead><tbody>
<tr><td>eq</td><td>Equal</td><td>Z == 1</td></tr>
<tr><td>ne</td><td>Not Equal</td><td>Z == 0</td></tr>
<tr><td>cs or hs</td><td>Carry Set</td><td>C == 1</td></tr>
<tr><td>cc or lo</td><td>Carry clear</td><td>C == 0</td></tr>
<tr><td>mi</td><td>Minus, negative</td><td>N == 1</td></tr>
<tr><td>pl</td><td>Plus, positive or zero</td><td>N == 0</td></tr>
<tr><td>vs</td><td>Overflow</td><td>V == 1</td></tr>
<tr><td>vc</td><td>No Overflow</td><td>V == 0</td></tr>
<tr><td>hi</td><td>Unsigned higher</td><td>C == 1 &amp;&amp; Z == 0</td></tr>
<tr><td>ls</td><td>Unsigned lower or same</td><td>!(C == 1 &amp;&amp; Z == 0)</td></tr>
<tr><td>ge</td><td>Signed greater than or equal</td><td>N == V</td></tr>
<tr><td>lt</td><td>Signed less than</td><td>N != V</td></tr>
<tr><td>gt</td><td>Signed greater than</td><td>Z == 0 &amp;&amp; N == V</td></tr>
<tr><td>le</td><td>Signed lessthan or equal</td><td>!(Z == 0 &amp;&amp; N == V)</td></tr>
</tbody></table>
<p>For example, the following instruction compares the values in 20 and w3 and copies the value in w3 to w0 if the condition specified is satisfied</p>
<blockquote>
<p>csel w0, w0, w3, ge</p>
</blockquote>
<p>If the value in w3 is greater than that in w0 then contents of w3 are copied to w0.</p>
<p>You can use the csel instruction in your program if you choose to. A solution without the instruction is also perfectly fine. Once you are done you can take a look at the code below (or in <em>exercises/integer_instructions/find_max_solution.s</em>).</p>
<details>
  <summary>Click to see the solution after you solve the problem</summary>
<pre><code class="language-armasm">    // Your code starts here
    mov    x4, x0

    // Initialize current maximum value with first element of array
    ldr    w0, [x0]

    // Check if there is only one element in the array
    cmp    w1, 1

    // Branch to done label if there is only one element
    beq    done

    // Set index to element 1
    mov    x2, 1

    // Iterate over array elements from index 2 and with current max
loop:
    ldr    w3, [x4, x2, lsl 2]

    // Compare the value against current maximum
    cmp    w0, w3

    // Select the new value if it is greater than current maximum
    csel    w0, w0, w3, ge

    // Increment the index
    add    x2, x2, 1

    // Check if we have iterated through all the elements of the array
    cmp    w1, w2

    // Branch back to beginning of loop if there are more elements
    bgt    loop
done:
    // Your code ends here
</code></pre>
</details>
<h2 id="counting-leading-zeroes"><a class="header" href="#counting-leading-zeroes">Counting leading zeroes</a></h2>
<p>In this exercise we will count the leading number of zeros in a given number. Leading zeroes are those that occur before the first 1 is encountered in the number when reading it left to right. For example, the number 0010_1011 has two leading zeroes.</p>
<p>For this exercise use the file <em>exercises/integer_instructions/clz.s</em>. We also introduce two new instructions - tbz and tbnz. In clz.s we have placed the number -  for which leading zeroes have to be found - in register w0. We will count the number of leading 0s in the given number and place the result in w0. The print function that is called later (already included in clz.s, you do not need to add it) will print the value stored in w0.</p>
<p>The code to find the number of leading zeroes is below. Try typing it out into the file and getting it working.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make clz.elf
RUN_COMMAND: make run
</code></pre>
<pre><code class="language-armasm">    // Your code starts here
    mov    w1, w0 //copy the number to w1

    // Initialize count to 0; we will use w0
    mov    w0, 0

    // Test if bit 31 of value is 1. If it is 1, branch to label 'done'
    tbnz    w1, #31, done

    // Keep left shifting the value by one until leftmost bit does not become 1
loop:
    // Left shift the value by 1
    lsl    w1, w1, 1

    // Increment the count by 1
    add    w0, w0, 1

    // Test if bit 31 is 1. If it is not 1, branch back to label 'loop'
    tbz    w1, #31, loop
done:
    // Your code ends here
</code></pre>
<p>The comments in the program should give enough information about how the code works. But there are a few new instructions that we will will go over.</p>
<p>Most of the instructions in the program should be familiar by now except <strong>tbz</strong>, <strong>tbnz</strong> and <strong>lsl</strong>. The <strong>lsl</strong> instruction takes three arguments, the destination register, the source register and a shift value. The instruction shifts the source register left by the specified amount and stores the result into the desination.</p>
<blockquote>
<p>lsl w1, w1, 1</p>
</blockquote>
<p>The above instruction shifts the value in w1 left by 1 and saves the result in w1. There is a variant of <strong>lsl</strong> where the shift value can be specified in a register. You will find the syntax for the instruction in Arm ARM.</p>
<p>The tbnz is a branch instruction that tests if the specified <strong>bit</strong>  in a given register is <strong>not zero</strong>. If the test result is true it branches to the label provided by the user. The <strong>tbz</strong> instruction checks if the bit is zero. If true it branches to the specified label.</p>
<h2 id="computing-the-factorial-of-a-number"><a class="header" href="#computing-the-factorial-of-a-number">Computing the Factorial of a number</a></h2>
<p>In this exercise we will compute the factorial of a number. Factorial value of a number 'N' is multiplication of all integers smaller than or equal to 'N'.</p>
<p>Mathematically it is written as:</p>
<pre><code>n! = 1 * 2 * 3 * 4 * ... * (n-1) * n
</code></pre>
<p>For example, factorial of 5 is:</p>
<pre><code>5 * 4 * 3 * 2 * 1 = 120
</code></pre>
<p>For this exercise use the file <em>exercises/integer_instructions/facorial.s</em>. In factorial.s we have placed - the number for which factorial will have to be computed - in register w0. We will compute the factorial and place the result in w0. The print function that is called later will print the value stored in w0.</p>
<p>We will first introduce the multiply instructions. There are multiply instructions that operate on 32-bit or 64-bit values and return a result of the same size as the operands. For example, two 64-bit registers can be multiplied to produce a 64-bit result with the MUL instruction.</p>
<pre><code>MUL &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;  // 32-bit variant
MUL &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;  // 64-bit variant
</code></pre>
<p>These instructions multiply the values in Wn(or Xn) and Wm(or Xm) and places the result in Wd(or Xd)</p>
<p>For example:</p>
<pre><code>MUL W0, W1, W2 // W0 = W1 * W2
</code></pre>
<p>Additionally, there are also multiply instructions that produce a long result, that is, multiplying two 32-bit numbers and generating a 64-bit result. There are both signed and unsigned variants of these long multiplies (UMULL, SMULL).</p>
<pre><code>UMULL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;  // Unsigned multiply long
SMULL &lt;Xd&gt;, &lt;Wn&gt;, &lt;Wm&gt;  // Signed multiply long
</code></pre>
<p>Below is pseudo code to compute the factorial. You can use this as a guide to write the assembly code.</p>
<ol>
<li>Use one register (say w0) to store the computed factorial(product) and initialize it with 1</li>
<li>Use one register (say w1) to increment the values from 2 to N-1 using a loop</li>
<li>Multiply current number in w1 with the product in w0 in each iteration of the loop</li>
</ol>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make factorial.elf
RUN_COMMAND: make run
</code></pre>
<details>
  <summary>The solution to this exercise is below (also in exercises/integer_instructions/factorial_solution.s)</summary>
<pre><code class="language-armasm">    // Your code starts here
    add    w2, w0, 1

    // Initialize w0 to 1.
    mov    w0, 1

    // Initialize w0 to 2.
    mov    w1, 2

    // Multiply numbers from 2 to N-1 with w0 using a loop
loop:
    // Multiply current number in w1 with the product in w0
    mul    w0, w0, w1

    // Increment the value in w1 by 1
    add    w1, w1, 1

    // Compare w1 and w2 to check if they are equal
    cmp    w2, w1

    // Branch back to label 'loop' if w1 is not equal to w2
    bne    loop

    // Your code ends here
</code></pre>
</details>
<h2 id="matrix-subtraction-and-addition"><a class="header" href="#matrix-subtraction-and-addition">Matrix subtraction and addition</a></h2>
<p>An array of arrays is known as two dimensional (2D) array or matrix. A matrix can be represented as a table of rows and columns. Data in 2D arrays are stored in tabular form. Elements in two-dimensional arrays are commonly referred to by a[i][j] where 'i' is the row number and 'j' is the column number and 'a' is the 2D array.</p>
<p>A two dimensional array can be seen as a table with 'M' rows and 'N' columns where the row number ranges from 0 to (M-1) and column number ranges from 0 to (N-1). A two dimensional array 'a' with 4 rows and 3 columns is shown below:</p>
<p><img src="images/matrix.png" alt="Matrix" title="Matrix" /></p>
<p>A matrix of 'M' rows and 'N' rows will have 'M * N' elements.  If a matrix has same number of rows and columns, then it is called as 'square' matrix.</p>
<p>The actual representation of this matrix in memory would be something like this:</p>
<p><img src="images/matrix_representation.png" alt="Matrix in memory" title="Matrix in memory" /></p>
<p>In this exercise, we will take two square matrices, 'A' and 'B' as input parameters and store the result in matrix 'C'. Two matrices can be added only if they have the same dimensions. The result will be a matrix of the same dimensions. To perform the addition, numbers in matching postions in the input matrices are added and the result is placed in the same position in the output matrix. Following diagram illustrates this by adding two 2x2 matrices 'A' and 'B' and places the result in matrix 'C'.</p>
<p><img src="images/matrix_add.png" alt="Matrix Addition" title="Matrix Addition" /></p>
<p>For this exercise use the file exercises/integer_instructions/matrix_addition.s. In matrix_addition.s, the program registers are initialized as follows:</p>
<ol>
<li>The start address of first square matrix to be added is in register x0</li>
<li>The start address of second square matrix to be added is in register x1</li>
<li>The start address of square matrix where the sum of matrix A and matrix B needs to be stored is in register x2</li>
<li>Register x3 holds the dimension of square matrices A, B  and C</li>
</ol>
<p>Below is pseudo code to add two matrices. You can use this as a guide to write the assembly code.</p>
<ol>
<li>Compute the total number of elements in the matrix using the register 'x3'</li>
<li>For each element in A, find the element at the same position in B (i.e. same row and column) and add the 2 values.</li>
<li>Place the result of this addition into result matrix C in the same position.</li>
</ol>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make matrix_addition.elf
RUN_COMMAND: make run
</code></pre>
<p>The solution for this exercise is provided in matrix_addition_solution.s. We recommend that you try to write the program your self before looking at the solution.</p>
<p>Matrix subtraction is very similar to matrix addition. The only difference is that we will use 'Subtract' operation instead of 'Add' operation in the above algorithm. There are 3 different variants of Subtract instructions in ARM architecture.</p>
<ol>
<li>Subtract (extended register)
Subtract (extended register) subtracts a sign or zero-extended register value, followed by an optional left shift
amount, from a register value, and writes the result to the destination register. The argument that is extended from
the <Rm> register can be a byte, halfword, word, or doubleword.</li>
</ol>
<pre><code>SUB &lt;Wd|WSP&gt;, &lt;Wn|WSP&gt;, &lt;Wm&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}  // 32-bit
SUB &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, &lt;R&gt;&lt;m&gt;{, &lt;extend&gt; {#&lt;amount&gt;}}  // 64-bit
</code></pre>
<ol start="2">
<li>SUB (immediate)
Subtract (immediate) subtracts an optionally-shifted immediate value from a register value, and writes the result to
the destination register.</li>
</ol>
<pre><code>SUB &lt;Wd|WSP&gt;, &lt;Wn|WSP&gt;, #&lt;imm&gt;{, &lt;shift&gt;} // 32-bit
SUB &lt;Xd|SP&gt;, &lt;Xn|SP&gt;, #&lt;imm&gt;{, &lt;shift&gt;}   // 64-bit
</code></pre>
<ol start="3">
<li>Subtract (shifted register) subtracts an optionally-shifted register value from a register value, and writes the result to
the destination register.</li>
</ol>
<pre><code>SUB &lt;Wd&gt;, &lt;Wn&gt;, &lt;Wm&gt;{, &lt;shift&gt; #&lt;amount&gt;}
SUB &lt;Xd&gt;, &lt;Xn&gt;, &lt;Xm&gt;{, &lt;shift&gt; #&lt;amount&gt;}
</code></pre>
<p>For this exercise use the file exercises/integer_instructions/matrix_subtract.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make matrix_subtract.elf
RUN_COMMAND: make run
</code></pre>
<p>We recommend that you try to write the program your self before looking at the solution in matrix_subtract_solution.s.</p>
<h2 id="printing-the-fibonacci-series"><a class="header" href="#printing-the-fibonacci-series">Printing the Fibonacci series</a></h2>
<p>Fibonacci series, named after an Italian mathematician, is a sequence of numbers, where every number is sum of the preceding two numbers. The first two numbers of the series are '0' and '1'.</p>
<p>Fibonacci series is:
<code>0, 1, 1, 2, 3, 5, 8, 13, 21, 34, . . . </code></p>
<p>We can notice that every number in this series is the sum of the preceding two numbers. The objective of this exercise, is to write code to store first N numbers of Fibonacci series in an array. The file exercises/integer_instructions/fibonacci.s has to be used for this challenge. Here is the information you need to write this program:</p>
<ol>
<li>The number of elements to be stored in the array is available in register x0</li>
<li>The memory address where fibonacci series will have to be stored is available in register x1</li>
</ol>
<p>Below is a pseudo code to generate the fibonacci series. You can use this as a guide to write the assembly code.</p>
<ol>
<li>Store value '0' and '1' as the first and second elements of array</li>
<li>Use a loop to store elements 2 to N of array so that each element is sum of previous two elements</li>
</ol>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make fibonacci.elf
RUN_COMMAND: make run
</code></pre>
<details>
  <summary>The solution to this exercise is below (also in exercises/integer_instructions/fibonacci_solution.s)</summary>
<pre><code class="language-armasm">    // Your code starts here

    // 0th of the series is 0
    mov    w2, #0
    str    w2, [x1]

    // 1st of the series is 1
    mov    w2, #1
    str    w2, [x1, #4]

    // Subtract the 2 values that has been initialized above from the size
    sub    w3, w0, #2

    // Increment the index
    add    x0, x1, #4

    // Determine the address of last element of array
    add    x3, x0, x3, uxtw 2

    mov    w1, #1
loop:

    // Load the previous-1 value. Previous value is already available in register w1
    ldr    w2, [x0, #-4]

    // Add the previous 2 numbers in the series
    add    w1, w1, w2

    // Increment the index
    add    x0, x0, #4

    // Store the value in array
    str    w1, [x0]

    // Check if we have stored required number of elements
    cmp    x0, x3

    // Branch back to beginning of loop if there are more elements
    bne    loop

    // Your code ends here
</code></pre>
</details>
<h1 id="logic-operations"><a class="header" href="#logic-operations">Logic Operations</a></h1>
<p>In this section we introduce a few more commonly used logic instructions. We will do this through a series of assembly programs.</p>
<p>Logical instructions are the instructions which perform basic logical operations such as OR, AND, XOR, and so on. The logical operations operate on individual bits of the register.</p>
<ul>
<li>The AND operation returns 1, if the matching bits from both the operands are 1, otherwise it returns 0.</li>
<li>The OR operator returns 1, if the matching bits from either or both operands are one. It returns 0, if both the bits are zero.</li>
<li>The XOR operation sets the resultant bit to 1, if and only if the bits from the operands are different. If the bits from the operands are same (both 0 or both 1), the resultant bit is cleared to 0.</li>
<li>The NOT operation reverses the bits in an operand.</li>
</ul>
<h2 id="print-the-xor-truth-table-eor"><a class="header" href="#print-the-xor-truth-table-eor">Print the XOR truth table (EOR)</a></h2>
<p>A truth table is used to specify the output value for each possible combination of input values. The figure below shows the truth table for NOT, AND, OR and XOR operations.</p>
<p><img src="images/truth_table.png" alt="Truth Table" title="Truth Table" /></p>
<p>The objective of this exercise, is to print the truth table for XOR operation. For this exercise use the file exercises/integer_instructions/xor_truth_table.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make xor_truth_table.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="multiply-and-divide-by-a-power-of-2-using-logical-left-shiftlsl-and-logical-right-shiftlsr-instructions"><a class="header" href="#multiply-and-divide-by-a-power-of-2-using-logical-left-shiftlsl-and-logical-right-shiftlsr-instructions">Multiply and divide by a power of 2 using Logical Left Shift(LSL) and Logical Right Shift(LSR) instructions</a></h2>
<p>We will start by first introducing the shift instructions:</p>
<ul>
<li>Logical Shift Left (LSL): The LSL instruction performs multiplication by a power of 2.</li>
<li>Logical Shift Right (LSR): The LSR instruction performs division by a power of 2.</li>
<li>Arithmetic Shift Right (ASR): The ASR instruction performs division by a power of 2, preserving the sign bit.</li>
<li>Rotate right (ROR): The ROR instruction performs a bitwise rotation, wrapping the bits rotated from the LSB into the MSB</li>
</ul>
<p><img src="images/shift_ops.png" alt="Shift Operators" title="Shift operators" /></p>
<p>The Logical Left Shift(LSL) and Logical Right Shift(LSR) instructions can also be used to perform multiply and divide operations:</p>
<ul>
<li>Multiplication with powers of 2 can be performed using left shift operator(LSL).</li>
<li>Division by powers of 2 can be performed using right shift operator(LSR).</li>
</ul>
<p>The objective of this exercise is to multiply and divide a number by a power of 2 using LSL and LSR instructions.</p>
<ol>
<li>Multiply the 32-bit value in register w0 by 128 using Left Shift Operator and place the result in register w8</li>
<li>Divide  the 32-bit value in register w1 by 64 using Right Shift Operator and place the result in register w9</li>
</ol>
<p>For this exercise use the file exercises/integer_instructions/shift_to_multiply_divide.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make shift_to_multiply_divide.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="count-the-number-of-1s-in-a-register"><a class="header" href="#count-the-number-of-1s-in-a-register">Count the number of 1's in a register</a></h2>
<p>The objective of this exercise is to count the number of 1s in the binary representation of an integer.</p>
<p>For example, let us consider an input value of 19. The binary representation of 19 is 10011 and has 3 set bits. Therefore, the result should be printed as 3. The figure below illustrates this.</p>
<p><img src="images/count_set_bits.png" alt="Count number of 1's in register" title="Count number of 1's in register" /></p>
<p>Below is a pseudo code to count 1's in register. You can use this as a guide to write the assembly code.</p>
<ol>
<li>Loop through all bits in an integer</li>
<li>Use a shift instruction to select the bit to be checked</li>
<li>Check if bit is set and increment the count if bit is set</li>
</ol>
<p>For this exercise use the file exercises/integer_instructions/count_ones.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make count_ones.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="count-leading-zeros-using-clz-instruction"><a class="header" href="#count-leading-zeros-using-clz-instruction">Count leading zeros using CLZ instruction</a></h2>
<ul>
<li>Refer earlier example in integer sectiom</li>
</ul>
<p>Counting leading zeroes in a number is such a common requirement in programs that the Arm ISA includes a specific instruction that does the job.</p>
<blockquote>
<p>clz &lt;Wd&gt;, &lt;Wn&gt;</p>
</blockquote>
<p>This instruction counts the nimber of leading zeroes of the number stored in Wn and places the result in Wd!! The result value is 32 if no bits are set in the source register, and zero if bit 31 is set. In this execercise let us redo the exercise using this instruction.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make clz_inst.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="what-we-learned-this-chapter-1"><a class="header" href="#what-we-learned-this-chapter-1">What we learned this chapter</a></h2>
<ul>
<li>Arrays and how they appear in memory</li>
<li>Integer instructions - ADD, SUB, TST, MUL</li>
<li>Transferring data between registers - MOV</li>
<li>Bit operations - AND, EOR, ORR, ASR, LSL, LSR, ROR</li>
</ul>
<p>In this section we learnt a few commonly used AArch64 integer instructions. There are several more integer instructions, and also different forms of the above instructions, defined in the ISA. We leave it to the reader to look up the <a href="https://developer.arm.com/documentation/ddi0487/ga">Arm ARM</a> for a comprehensive list.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="condition-flags"><a class="header" href="#condition-flags">Condition Flags</a></h1>
<p>In <a href="condition_flags.html#Arm-Registers-and-Execution-State">Arm Registers and Execution State</a> we introduced the condition flags. In the previous section, we have already used arithmetic instructions like <strong>cmp</strong> that set the condition flags and instructions like b.gt that makes use of condition flags. In this section we introduce more such instructions and then work through a series of examples. We will also explain how the condition flags are used to implement conditional execution of instructions.</p>
<p>Condition flags are a set of bits that store state information about a previous operation. There are four condition flags:</p>
<table><thead><tr><th>Flag</th><th>Name</th><th>Description</th></tr></thead><tbody>
<tr><td>N</td><td>Negative flag</td><td>Set to 1 if the result of the last flag-setting instruction was negative</td></tr>
<tr><td>Z</td><td>Zero flag</td><td>Set to 1 if the result of the last flag-setting instruction was zero, and to 0 otherwise</td></tr>
<tr><td>C</td><td>Carry flag</td><td>Set to 1 if the last flag-setting instruction resulted in a carry condition, for example an unsigned overflow on an addition</td></tr>
<tr><td>V</td><td>oVerflow flag</td><td>Set to 1 if the last flag-setting instruction resulted in an overflow condition, for example a signed overflow on an addition</td></tr>
</tbody></table>
<p>Each flag is a 1-bit value, so that there can only be two valid values:  0 (clear) or 1 (set). These flags indicate simple properties such as whether or not the result was negative, and can also be used in various combinations to identify conditions such as &quot;less than or equal to&quot;.</p>
<p>The N flag represents the sign of the result of the previous operation. If say the operation was an addition (or subtraction, mutiplication, division etc) and the result was a negative number then this flag is set. If the result was a positive number then this flag is cleared.</p>
<p>The Z flag, when set, indicates that the output of the previous instruction was zero. </p>
<p>The C flag is called the carry flag. This flag is set if an arithmetic operation results in an arithmetic <em>carry</em> or <em>borrow</em>. For example an unsigned overflow on an addition and can be used to perform unsigned arithmetic operations.</p>
<p>The V flag indicates that the previous operation resulted in an arithmetic <em>overflow</em>. For example a signed overflow on an addition. The C flag is set if the result of an unsigned operation overflows the result register. The V flag operates in the same way as the C flag, but for signed operations. For example, 0x7fffffff is the largest positive two's complement integer that can be represented in 32 bits, so 0x7fffffff + 0x7fffffff triggers a signed overflow, but not an unsigned overflow (or carry): the result, 0xfffffffe, is correct if interpreted as an unsigned quantity, but represents a negative value (-2) if interpreted as a signed quantity.</p>
<p><strong>Flag setting instructions</strong>:</p>
<p>The condition flags are set by dedicated comparison instruction like CMP, CMN and TST. These comparison instructions only modify the flags and have no other effect. There are also certain Arithmetic and Logical instructions with S suffix (indicating that the instruction sets flags) that can modify the condition flags. For example: ADDS, SUBS, ADCS, SBCS, ANDS, and BICS.</p>
<p>Integer instructions like ADDS, SUBS, ADCS, SBCS, CMP, CMN can affect all the four condition flags whereas logical instructions like ANDS, BICS and TST can set only N and Z flags.</p>
<p>Let us now look in more detail on how the condition flag bits for each operation.</p>
<p><strong>Addition operation</strong>:</p>
<p>For addition operation instructions like ADDS, ADCS:</p>
<ul>
<li>N bit is set when MSB of result is 1</li>
<li>Z bit is set when result is 0</li>
<li>C bit is set when addition results in carry</li>
<li>V bit is set when:
<ul>
<li>Positive + Positive = Negative</li>
<li>Negative + Negative = Positive</li>
</ul>
</li>
</ul>
<p><strong>Subtraction operation</strong>:</p>
<p>For subtraction operation instructions like SUBS, SBCS:</p>
<ul>
<li>N bit is set when MSB of result is 1</li>
<li>Z bit is set when result is 0</li>
<li>C bit is set when subtraction results in borrow</li>
<li>V bit is set when:
<ul>
<li>Negative - Positive = Positive</li>
<li>Positive - Negative = Negative</li>
</ul>
</li>
</ul>
<p><strong>Logical operation</strong>:</p>
<p>For logical operation instructions like ANDS, BICS:</p>
<ul>
<li>N bit is set when MSB of result is 1</li>
<li>Z bit is set when result is 0</li>
<li>C bit is always cleared to 0 </li>
<li>V bit is always cleared to 0 </li>
</ul>
<p>Let us now go through some examples to determine the NZCV values after a flag setting instruction is executed: </p>
<p>Example 1:</p>
<table><thead><tr><th>Operation</th><th>Operand 1</th><th>Operand 2</th><th>Result</th></tr></thead><tbody>
<tr><td>ADDS</td><td>0x50000000</td><td>0x50000000</td><td>0xA0000000</td></tr>
</tbody></table>
<details>
  <summary>Click to see the solution after you solve the problem</summary>
<pre><code> N = 1, Z = 0, C = 0, V = 1
</code></pre>
</details>
<p>Example 2:</p>
<table><thead><tr><th>Operation</th><th>Operand 1</th><th>Operand 2</th><th>Result</th></tr></thead><tbody>
<tr><td>Addition</td><td>0x80000000</td><td>0x80000000</td><td>0x00000000</td></tr>
</tbody></table>
<details>
  <summary>Click to see the solution after you solve the problem</summary>
<pre><code> N = 0, Z = 1, C = 1, V = 1
</code></pre>
</details>
<p>Example 3:</p>
<table><thead><tr><th>Operation</th><th>Operand 1</th><th>Operand 2</th><th>Result</th></tr></thead><tbody>
<tr><td>Addition</td><td>0x80000000</td><td>0x90000000</td><td>0x10000000</td></tr>
</tbody></table>
<details>
  <summary>Click to see the solution after you solve the problem</summary>
<pre><code> N = 0, Z = 0, C = 1, V = 1
</code></pre>
</details>
<p>Example 4:</p>
<table><thead><tr><th>Operation</th><th>Operand 1</th><th>Operand 2</th><th>Result</th></tr></thead><tbody>
<tr><td>Subtraction</td><td>0x00001678</td><td>0x00001000</td><td>0x00000678</td></tr>
</tbody></table>
<details>
  <summary>Click to see the solution after you solve the problem</summary>
<pre><code> N = 0, Z = 0, C = 1, V = 0
</code></pre>
</details>
<p>Example 5:</p>
<table><thead><tr><th>Operation</th><th>Operand 1</th><th>Operand 2</th><th>Result</th></tr></thead><tbody>
<tr><td>Subtraction</td><td>0x00000006</td><td>0x00000007</td><td>0xFFFFFFFF</td></tr>
</tbody></table>
<details>
  <summary>Click to see the solution after you solve the problem</summary>
<pre><code> N = 1, Z = 0, C = 0, V = 0
</code></pre>
</details>
<p>Example 6:</p>
<table><thead><tr><th>Operation</th><th>Operand 1</th><th>Operand 2</th><th>Result</th></tr></thead><tbody>
<tr><td>Subtraction</td><td>0xFFFFFFFF</td><td>0xFFFFFFFB</td><td>0x00000004</td></tr>
</tbody></table>
<details>
  <summary>Click to see the solution after you solve the problem</summary>
<pre><code> N = 0, Z = 0, C = 1, V = 0
</code></pre>
</details>
<p>Example 7:</p>
<table><thead><tr><th>Operation</th><th>Operand 1</th><th>Operand 2</th><th>Result</th></tr></thead><tbody>
<tr><td>Subtraction</td><td>0xD0000004</td><td>0xD0000003</td><td>0x00000001</td></tr>
</tbody></table>
<details>
  <summary>Click to see the solution after you solve the problem</summary>
<pre><code> N = 0, Z = 0, C = 1, V = 0
</code></pre>
</details>
<p>Example 8:</p>
<table><thead><tr><th>Operation</th><th>Operand 1</th><th>Operand 2</th><th>Result</th></tr></thead><tbody>
<tr><td>Subtraction</td><td>0x70000000</td><td>0xF0000000</td><td>0x80000000</td></tr>
</tbody></table>
<details>
  <summary>Click to see the solution after you solve the problem</summary>
<pre><code> N = 1, Z = 0, C = 0, V = 1
</code></pre>
</details>
<p>Example 9:</p>
<table><thead><tr><th>Operation</th><th>Operand 1</th><th>Operand 2</th><th>Result</th></tr></thead><tbody>
<tr><td>Subtraction</td><td>0xB0000000</td><td>0xB0000000</td><td>0x00000000</td></tr>
</tbody></table>
<details>
  <summary>Click to see the solution after you solve the problem</summary>
<pre><code> N = 0, Z = 1, C = 1, V = 0
</code></pre>
</details>
<p>We have worked out how the condition flags are set. Let us now see how does that enable conditional execution of code by introducing instructions that read the condition flags.</p>
<p><strong>Program flow control instructions</strong></p>
<p>Program flow instructions gives the ability to make decisions on what code to execute next. The instruction set enables conditional execution of program flow control branch instructions. The branch instructions can be broadly categorized to two types:</p>
<ul>
<li>Unconditional branches: Unconditional branches do not consider the NZCV flags and they can branch backward or forward up to 128MB from the current program counter location.</li>
<li>Conditional branches: Conditional branches use the NZCV condition flags to decide whether branch operation should be performed or not. Most conditional branches have a range of +/-1MB.</li>
</ul>
<p>The instruction set provides a number of different kinds of branch instructions. Majority of the branch instructions use relative addressing. That is, they branch to an offset from the current address and are called relative branches. An example is B.cond instruction, where 'cond' is one of the fourteen possible condition suffixes. In effect, attaching one of the condition codes to the B instruction causes it to branch to specified offset if the condition(cond) is true. Otherwise, it does nothing, and is essentially a nop. The following table lists the available condition codes, their meanings, and the flags that are tested:</p>
<table><thead><tr><th>Mnemonic</th><th>Meaning (integer)</th><th>Condition Flags</th></tr></thead><tbody>
<tr><td>eq</td><td>Equal</td><td>Z == 1</td></tr>
<tr><td>ne</td><td>Not Equal</td><td>Z == 0</td></tr>
<tr><td>cs or hs</td><td>Carry Set</td><td>C == 1</td></tr>
<tr><td>cc or lo</td><td>Carry clear</td><td>C == 0</td></tr>
<tr><td>mi</td><td>Minus, negative</td><td>N == 1</td></tr>
<tr><td>pl</td><td>Plus, positive or zero</td><td>N == 0</td></tr>
<tr><td>vs</td><td>Overflow</td><td>V == 1</td></tr>
<tr><td>vc</td><td>No Overflow</td><td>V == 0</td></tr>
<tr><td>hi</td><td>Unsigned higher</td><td>C == 1 &amp;&amp; Z == 0</td></tr>
<tr><td>ls</td><td>Unsigned lower or same</td><td>!(C == 1 &amp;&amp; Z == 0)</td></tr>
<tr><td>ge</td><td>Signed greater than or equal</td><td>N == V</td></tr>
<tr><td>lt</td><td>Signed less than</td><td>N != V</td></tr>
<tr><td>gt</td><td>Signed greater than</td><td>Z == 0 &amp;&amp; N == V</td></tr>
<tr><td>le</td><td>Signed lessthan or equal</td><td>!(Z == 0 &amp;&amp; N == V)</td></tr>
</tbody></table>
<p>The first few  condition codes would be quite obvious as they test individual flags, but the others rely on specific combinations of flags. However, the understanding of exact flags that would be used for each condition code will be rarely required.</p>
<p>In addition to the above PC-relative instructions, the instruction set includes absolute branches. The BR Xn instruction performs an absolute branch to the address in Xn.</p>
<p>The instruction set includes some special conditional branches so that explicit comparison instructions are not needed.</p>
<ul>
<li>CBZ Rt, label  : Compare and branch if zero</li>
<li>CBNZ Rt, label : Compare and branch if not zero
These instructions compare the source register, either 32-bit or 64-bit, with zero and then conditionally perform a branch. The branch offset has a range of +/- 1MB. These instructions do not read or write the condition code flags (NZCV).</li>
</ul>
<p>There are two similar test and branch instructions </p>
<ul>
<li>TBZ Rt, bit, label  : Test and branch if Rt<bit> zero</li>
<li>TBNZ Rt, bit, label : Test and branch if Rt<bit> is not zero
These instructions test the bit in the source register at the bit position specified by the immediate and conditionally branch depending on whether the bit is set or clear. The branch offset has a range of +/- 32kB. As with CBZ/CBNZ, these instructions do not read or write the condition code flags (NZCV).</li>
</ul>
<p>The table below summarizes the supported branch instructions along with brief explanation of the operation:</p>
<table><thead><tr><th>Instruction</th><th>Description</th></tr></thead><tbody>
<tr><td>B (offset)</td><td>Program relative branch forward or back 128MB. A conditional version, for example B.EQ, has a 1MB range.</td></tr>
<tr><td>BR Xn</td><td>Absolute branch to address in Xn</td></tr>
<tr><td>CBZ Rt, label</td><td>Compare and branch if zero. If Rt is zero, branch forward or back up to 1MB.</td></tr>
<tr><td>CBNZ Rt, label</td><td>Compare and branch if non-zero. If Rt is not zero, branch forward or back up to 1MB.</td></tr>
<tr><td>TBNZ Rt, bit, label</td><td>Test and branch if zero. Branch forward or back up to 32kB.</td></tr>
<tr><td>TBNZ Rt, bit, label</td><td>Test and branch if non-zero. Branch forward or back up to 32kB.</td></tr>
</tbody></table>
<p><strong>Conditional select</strong></p>
<p>The instruction set also provides instructions to perforn conditional select with optional increment, negate, or invert. These can be used to conditionally select between one source register and a second incremented, negated, inverted, or unmodified source register. </p>
<p>The table below summarizes the conditional select instructions:</p>
<table><thead><tr><th>Instruction</th><th>Description</th></tr></thead><tbody>
<tr><td>CSEL</td><td>Select between two registers based on a condition.</td></tr>
<tr><td>CSINC</td><td>Select between two registers based on a condition. Result would be value of the first source register or the second source register incremented by one.</td></tr>
<tr><td>CSINV</td><td>Select between two registers based on a condition. Result would be value of the first source register or the inverted second source register.</td></tr>
<tr><td>CSNEG</td><td>Select between two registers based on a condition. Result would be value of the first source register or the negated second source register.</td></tr>
</tbody></table>
<p>One typical use of these instructions is conditional counting. For example:
CSINC X0, X1, X0, NE 
The above instruction sets the return register X0 to X1 if Zero flag clear, otherwise it increments X0.</p>
<p>This class of instructions can also be used to avoid the use of branches. </p>
<p>NOTE: The following example can be later moved to C programming section</p>
<p>For example, consider the simple C code:</p>
<pre><code>if (i == 0) x = x + 5; else x = x - 2;

</code></pre>
<p>This might be written in assembly using following code:</p>
<pre><code>CMP w0, #0 // if (i == 0)
SUB w2, w1, #2 // x = x - 2
ADD w1, w1, #5 // x = x + 5
CSEL w1, w1, w2, EQ // select between the two results
</code></pre>
<p>The instruction set also provides following additional instructions that use condition codes:</p>
<ul>
<li>Condition Set (CSET/CSETM) : Conditionally select between 0 and 1 (CSET) or 0 and -1 (CSETM). Used, for example, to set the condition flags as a boolean value or mask in a general register.</li>
<li>Conditional compare (CCMP/CCMN):  Sets the condition flags to the result of a comparison if the original condition is true. If not true, the conditional flags are set to a specified condition flag state. The conditional compare instruction is very useful for expressing nested or compound comparisons</li>
</ul>
<p><strong>Add/Subtract with Carry</strong>
In addition to conditional instructions described above, the Carry bit of the condition code can also be used to extend add and subtract operations. These instructions are unconditionally executed but use the condition flags as an extra input to the instruction. For example: ADC(add with carry), SBC(Subtract with carry). </p>
<p>The operations ADC and SBC perform additions and subtractions that also use the carry condition flag as an input as shown below.</p>
<pre><code>ADC{S}: Rd = Rn + Rm + C
SBC{S}: Rd = Rn - Rm - 1 + C
</code></pre>
<p>These instructions can be used for performing multi-precision arithmetic and checksums.</p>
<h2 id="what-we-learned-this-chapter-2"><a class="header" href="#what-we-learned-this-chapter-2">What we learned this chapter</a></h2>
<ul>
<li>Condition flags and their meaning</li>
<li>Instructions that set condition code - CMP, TST, ADDS, SUBS, ADCS, SBCS, ANDS, BICS</li>
<li>Program flow control instructions</li>
<li>Instructions that make use of conditional flags </li>
</ul>
<hr />
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-stack"><a class="header" href="#the-stack">The Stack</a></h1>
<p>The stack is a data structure used in computer science. It is analogous to a stack of plates where one can add a plate to the top or remove a plate from the top but not from any arbitrary location. Below is a visual representation of a stack holding data (in this case numbers).</p>
<p><img src="./images/stack1.png" alt="Example of Stack" /></p>
<p>The figure above shows the representation of a stack that holds integers. Here the bottom-most element is the number 5. The topmost element is 36. Operations can only be performed on the top of the stack. A <em>push</em> operation adds an element to the top of the stack. After we push 10 onto the stack it looks like the image below. New data can only be added using the push operation and that data will always be added to the top of the stack. Any number of items can be pushed onto the stack and they will all be added, one by one, to the top of the stack.</p>
<p><img src="./images/stack2.png" alt="Push and Pop Stack" /></p>
<p>A <em>pop</em> operation removes and returns the topmost item on the stack. Only the top item in the stack may be removed from the stack. To remove the second item on the stack one would have to remove the 1st and 2nd items (i.e. two pops).</p>
<p>The stack, in the context of computer architecture, is location in memory that is used to store temporary data. For example, local variables, arguments passed into functions, and arguments returned from functions. In some architectures this hardware stack operates exactly like the stack data structure. One can &quot;push data onto the stack&quot; and &quot;pop data off the stack&quot; using special instructions. In ARM AArch64 the stack is a little more flexible. Load and store instructions we saw in the <a href="./memory_inst.html">memory instructions section</a> can be used to access data contained in the stack. The programmer can directly write to or read from any data contained in the stack. A special register called stack register (SP) is used to track the memory address of the top of the stack.</p>
<h2 id="pushing-and-popping-the-stack-in-aarch64"><a class="header" href="#pushing-and-popping-the-stack-in-aarch64">Pushing and popping the stack in AArch64</a></h2>
<p>By convention SP points to the last data pushed onto the stack. To push data on the stack one we can use store instructions. Here is an example of pushing two registers onto the stack.</p>
<pre><code>stp x0, x1, [sp, #-16]!

</code></pre>
<p>The <strong>STP</strong> instruction is a store variant that we have not covered so far. This instruction stores a pair of registers into the memory location starting at the address computed by subtracting 16 from the contents of the <strong>SP</strong> register. In addition, the instruction also updates the value in <strong>SP</strong> to point to the new memory location that is the top-of-stack.</p>
<p>The other important thing to notice is that the address of the stack pointer is decremented. In AArch64 the stack grows downwards from high address to lower addresses.</p>
<p>When the SP register is used as the address of a load or store the address contained in the register <strong>must be 16-byte aligned</strong>. The address in SP must be perfectly divisible by 16. This means that the lowest 4 bits (i.e. [3:0]) of the register must be 0b000.</p>
<p>So if we try to push x1 and x0 onto the stack one by one, like this</p>
<pre><code> str x1, [sp, -#8] //stack gets mis-aligned
 str x0, [sp, #-8] //this instruction will trigger an alignment exception
</code></pre>
<p><strong>the code will trigger an alignment fault.</strong> The first <strong>str</strong> instruction subtracts 8 from SP. Assuming that the SP was initially 16-byte aligned, after executing the first instruction it is no longer 16-byte aligned.</p>
<p>So when pushing onto the stack one needs to ensure that <strong>SP</strong> is always aligned. If the programmer, for any reason, desires to push  two registers onto the stack one by one then the first push can be used to create the space needed for all the data. Here is an example:</p>
<pre><code>str x0, [sp, -#16]! //store x0 at sp-16 and updates sp = sp -16
str x1, [sp, #8]    //store x1 at address sp + 8. Do not change sp.

//After executing the above code the SP register will point to the
//memory location containing x0 and x1 will be at the address SP+8
</code></pre>
<p>Popping data from the stack can be done using load instructions. For example:</p>
<pre><code> ldp x0, x1, [SP], #16
</code></pre>
<h2 id="what-we-learned-2"><a class="header" href="#what-we-learned-2">What we learned</a></h2>
<ol>
<li>Stack pointer in AArch64</li>
<li>How to push and pop data</li>
<li>Stack pointer relative load and store</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>When developing large programs it is useful break down the code into smaller more manageable pieces. This an be done by placing frequently occurring instructions into functions. Organising code this way offers these advantages:</p>
<ul>
<li>It provides the program structure and enables better understanding of the code.</li>
<li>Code is re-used therefore overall program size (i.e. lines of code) becomes smaller. It also becomes easier to test and fix errors.</li>
</ul>
<p>For example, say we are developing software for a scientific application and the algorithm we are using requires us to compute the sum of 1 to n numbers at different points in the code. The number n can change at different places in the program. First, we write the code to compute the sum of numbers.</p>
<pre><code class="language-armasm"> //The general formula for the sum of numbers from 1 to n is sum = n * (n+1)/2
 //Number to be placed in w0
 add w1, w0, #1    //Compute n+1
 mul w1, w0, w1    //Compute n * (n+1)
 lsr w1, w1, #1    //Divide the result by 2
</code></pre>
<p>In the assembly code we expect that the value of n (an unsigned integer) should be made available in register w0. The three lines above will then compute the sum of integers from 1-n and place the result in w1. Note that to divide by 2 we use the lsr (right shift) instruction. If you do not understand how the lsr instruction is equivalent to division, review the chapters on binary arithmetic and integer instructions.</p>
<p>Now back to the complex (hypothetical) program we were developing...</p>
<p>We want to compute the sum of n integers at different points in our program. At each instance we want to compute the sum up to a different n. Sometimes the sum of numbers from 1-6, sometimes from 1-22 and later in the program 1-n (where n can be a different number). Example of the really large program:</p>
<pre><code class="language-armasm">//Lots of complicated scientific computations
.
.
.
mov w0, #6
//Compute sum of integers from 1-6
add w1, w0, #1    //Compute n+1
mul w1, w0, w1    //Compute n * (n+1)
lsr w1, w1, #1    //Divide the result by 2

//Use value in w1 as an input to more complicated computations...
.
.
.
mov w0, #22
//Compute sum of integers from 1-22
add w1, w0, #1    //Compute n+1
mul w1, w0, w1    //Compute n * (n+1)
lsr w1, w1, #1    //Divide the result by 2

//Use value in w1 as an input to more complicated computations...
.
.
.
//So on and so forth
</code></pre>
<p>We could write our program as shown above and it will work. But the program is really long and difficult to understand. Also, if we made a mistake in typing the code to compute the sum of n integers anywhere in the program it could lead to errors.</p>
<p>One way to reduce the program size (number of instructions) would be to some how write the code to compute sum of N numbers only once. Wherever the sum-of-N needs to be computed in our program we can branch to the code that computes it and branch back once the value is computed.</p>
<p>What we want to do is restructure our program to something like this:</p>
<pre><code class="language-armasm">sumOfN:
//Compute sum of integers from 1-n where n is given by the caller in w0
add w1, w0, #1    //Compute n+1
mul w1, w0, w1    //Compute n * (n+1)
lsr w1, w1, #1    //Divide the result by 2
//Return to the appropriate location. Huh, how do I do that?

//Main program starts here...
//Lots of complicated scientific computations
.
.
.
mov w0, #6
b sumOfN //Branch to the code that computes sum-of-N

//Once sumOfN is done we need to execute from the instruction below

//Use value in w1 as an input to more complicated computations...
.
.
.
mov w0, #22
b sumOfN //Branch to the code that computes sum-of-N

//Once sumOfN is done we need to execute from the instruction below

//Use value in w1 as an input to more complicated computations...
.
.
.
//So on and so forth

</code></pre>
<p>However, this does not work (yet). Why so? Well, we can use an unconditional branch instruction to keep jumping to the code to compute sumOfN. <strong>But, after executing the code at sumOfN, how do we get back to the next instruction in the program?</strong> At each instance in the program where we jump to sumOfN the code has to return to the immediate next instruction. So the location to jump back after executing sumOfN changes.</p>
<p>What we want is to be able to jump to sumOfN when needed, execute it, and jump back to the location from where we &quot;called&quot; the sumOfN &quot;function&quot;. There are a few special instructions in the ARM ISA that can be used to accomplish this objective. The first one is the &quot;branch with link&quot; instruction (BL, BLR). This instruction is used to jump from any location in code to the start of a function. The second instruction is the return (RET) instruction that returns from the function back to the instruction just after BL/BLR.</p>
<p>The branch with link instruction stores the address of the next instruction (i.e. the instruction following itself) into register X30 and jumps to the memory location specified by the programmer.</p>
<p>Branch with link variants</p>
<ul>
<li>BL immediate_address  : address to branch is encoded as an immediate</li>
<li><em>BLR &lt;X<sub>n</sub>&gt;</em>   : address to branch is contained in X register</li>
</ul>
<p>The <em>RET {&lt;X<sub>n</sub>&gt;}</em> instruction is the last instruction in a function. It jumps to the address contained in the specified register. If the register name is omitted the contents of X30 are used as the address to jump to.</p>
<p>So here is what our large program looks like with BL and RET instructions added.</p>
<pre><code class="language-armasm">sumOfN:
  //Compute sum of integers from 1-n where n is given by the caller in w0
  add w1, w0, #1    //Compute n+1
  mul w1, w0, w1    //Compute n * (n+1)
  lsr w1, w1, #1    //Divide the result by 2
  ret               //Return to the address in X30

//Main program starts here...
//Lots of complicated scientific computations
.
.
.
mov w0, #6
bl sumOfN //Branch to the code that computes sum-of-N

//Once sumOfN is done execution begins from the instruction below
//Use value in w1 as an input to more complicated computations...
.
.
.
mov w0, #22
bl sumOfN //Branch to the code that computes sum-of-N

//Once sumOfN is done execution begins from the instruction below
//Use value in w1 as an input to more complicated computations...
.
.
.
//So on and so forth

</code></pre>
<p>Note that it is possible to use just plain branch instruction to jump to sumOfN and back. We can do this by storing the return address in a X register ourselves and then jumping back to the address in that register. However, using BL/BLR and RET gives hint to the processor that a function is being called and will eventually return. The processor can use this information to execute the program more optimally.</p>
<p>The key points to understand from the above discussion are:</p>
<ul>
<li>Jump to functions using <em>BL/BLR</em>, return from the function using <em>RET</em></li>
<li>X30 is a special register that is used by <em>BL</em> to store the return address</li>
</ul>
<h2 id="execise-1a-function-to-count-leading-zeros"><a class="header" href="#execise-1a-function-to-count-leading-zeros">Execise 1A: Function to count leading zeros</a></h2>
<p>Write a function to count the number of leading zeros. The template for this exercise is provided in exercises/functions/count_leading_zeros.s and the solution is at exercises/functions/count_leading_zeros_solution.s</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make count_leading_zeros.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="nested-function-calls"><a class="header" href="#nested-function-calls">Nested Function Calls</a></h2>
<p>In a program it is possible for one function to call another. For example, sumOfN function could call addOne to add 1 to the value passed in.</p>
<pre><code class="language-armasm">sumOfN:
  //Compute sum of integers from 1-n where n is given by the caller in w0
  mov w1, w0          //Save the value of w0
  str x30, [sp, -#16]! //Save the value of X30 onto the stack, also change SP
  bl addOne
  ldr x30, [sp], #16   //Load the saved value of x30 back from stack
  mul w1, w0, w1    //Compute n * (n+1)
  lsr w1, w1, #1    //Divide the result by 2
  ret               //Return to the address in X30

addOne:
  add w1, w0, #1    //Compute n+1
  ret

</code></pre>
<p>When we use the <em>BL/BLR</em> to call a function the return address is stored in X30. So, from our program when we call sumOfN the return address is stored in X30. From sumOfN, when  we call addOne the X30 register will be overwritten with the address of the instruction to return to after executing addOne. Therefore, we save the contents of X30 in the stack before calling addOne function. After the function call we restore the contents of X30 from the stack and then return from sumOfN.</p>
<p>Why save and restore X30 from the stack? Why not save it another register?</p>
<p>In a real program, the other registers may be holding values used in  computation and so may not be available. Plus we do not know if the function being called would overwrite our chosen register. Therefore, the correct practice is to use the stack to save X30.</p>
<h2 id="passing-parameters-via-registers"><a class="header" href="#passing-parameters-via-registers">Passing parameters via registers</a></h2>
<p>Some functions may need data to be given to them to operate. For example the sumOfN and the addOne functions we used earlier needed input values. We passed the value N to sumOfN and the value to be incremented to addOne. In both cases the value was placed in register <em>w0</em> before we called the corresponding functions. The values that are passed to functions are called parameters.</p>
<p>Parameters are passed quite commonly using registers. By convention and as specified in the <a href="https://github.com/ARM-software/abi-aa/releases">Arm Procedure Call Standard</a> registers <em>r0-r7</em> are used to pass parameters. If more than 8 parameters have to be passed to a function the remaining can be passed by pushing them on the stack.</p>
<p>The <em>r0-r7</em> registers can also be used to return values from the function. In the example above we used the <em>w1</em> register to return values from the function.</p>
<h2 id="exercise-1b-memcopy-as-a-function"><a class="header" href="#exercise-1b-memcopy-as-a-function">Exercise 1B: Memcopy as a function</a></h2>
<p>We have implemented memcopy as a function and the code is shown below.
Comments in the code explain how it is intended to work. However, in the present form the code has a bug (error). Can you spot the error and fix the problem.</p>
<pre><code class="language-armasm">
// Function to copy a string
memcopy_string:
    sub sp, sp, 32     // Adjust sp
    str x19, [sp, 8]   // Save x19 (local var 1)
    str x20, [sp, 16]  // Save x20 (local var 2)

    mov x19, x0 // Store str1 in local var1 (x19)
    mov x20, x1 // Store str2 in local var2 (x20)

    // Find the string length
    bl find_string_length

    mov x2, x0  // Move length value to x2(third argument)
    mov x0, x19 // Move str1 to x0(first argument)
    mov x1, x20 // Move str2 to x1(second argument)

    mov	  x19, #0x0    // Maintain count in local var 1(x19)
copy_loop_start:
    ldrb  w20, [x0, x19]  // Use local var 2(x20) to hold temporary results
    strb  w20, [x1, x19]
    add	  x19, x19, #0x1
    cmp	  x2, x19
    b.gt  copy_loop_start

    ldr x19, [sp, 8]   // Restore x19
    ldr x20, [sp, 16]  // Restore x20

    add sp, sp, 32     // Adjust sp

    ret


// Helper function to find length of a string
find_string_length:
    sub sp, sp, 32    // Adjust sp
    str x30, [sp]     // Save x30
    str x19, [sp, 8]  // Save x19 (local var 1)
    str x20, [sp, 16] // Save x20 (local var 2)

    mov   x19, #0         // Maintain count in local var 1(x19)
    ldrb  w20, [x0, x19]  // Use local var 2(x20) to hold temporary results
    cbz   x20, find_len_end
find_len_start:
    add   x19, x19, #0x1
    ldrb  w20, [x0, x19]
    cbnz  x20, find_len_start

find_len_end:
    mov x0, x19  // Move return value to x0

    ldr x19, [sp, 8]    // Restore x19
    ldr x20, [sp, 16]   // Restore x20

    ldr x30, [sp]       // Restore x30
    add sp, sp, 32      // Adjust sp

    ret

</code></pre>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make memcopy_register.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="register-usage-conventions"><a class="header" href="#register-usage-conventions">Register usage conventions</a></h2>
<p>So far we have been talking about small programs where we use very few of the available Arm registers. However, large programs can have millions of lines of code written in collaboration by programmers. These programs have many functions. It is quite common for programmers to rely on libraries for specific purposes. Those libraries may have been written by other programmers (in a different company/organization).</p>
<p>A library can be thought of a set of functions the implement specific actions. For example, a math library can implement different mathematical operations. The functions in the library can be used by other programmers in their own programs.</p>
<p>Even though the architecture permits the programmer to use registers <em>r0-r30</em> as they choose, in practice sharing code makes it necessary to have some conventions. For example, a programmer could write a library with functions that expect input parameters in registers <em>r13-r20</em>. How would others using that code know to pass parameters using those specific registers? One could say - &quot;read the documentation&quot;. But if every programmer were to pick their own favorite registers for different purposes then there would be a lot of documentation to read and adhere to - a total mess.</p>
<p>Also, most programs are written in higher level programming languages like C/C++, Rust, Swift etc. Compilers (in combination with assemblers) convert programs written in these languages to assembly and after that to machine code. Using a common convention will make it easier for code compiled using different compilers to correctly interoperate.</p>
<p>The <a href="https://github.com/ARM-software/abi-aa/releases">Arm procedure call standard</a> (PCS) prescribes a convention to be followed for using registers. Following this convention ensures that assembly (or higher level language) code written by different programmers will interoperate without any problems.</p>
<p>The table below is from the Arm PCS. Readers are encouraged to refer to the full documentation for details.</p>
<table><thead><tr><th>Registers</th><th>Role</th></tr></thead><tbody>
<tr><td>r0-r7</td><td>parameters and result registers</td></tr>
<tr><td>r8</td><td>indirect result location register</td></tr>
<tr><td>r9-r15</td><td>temporary registers</td></tr>
<tr><td>r16-r17</td><td>intra-procedure-call temporary register; used by the linker as scratch registers</td></tr>
<tr><td>r18</td><td>temporary register</td></tr>
<tr><td>r19-r28</td><td>callee-saved registers</td></tr>
<tr><td>r29</td><td>frame pointer</td></tr>
<tr><td>r30</td><td>link register</td></tr>
<tr><td>SP</td><td>stack pointer</td></tr>
</tbody></table>
<p><strong>Note:</strong> The stack pointer (SP) sould only be used to hold the address of top of stack. Register <em>r30</em> (link register) should be used to hold the address of a return.</p>
<p>As per the PCS, <em>r0-r7</em> are to be used for parameters and results. A called function may change the contents of these registers. So programmers should not expect these register contents will be preserved after a function call. Registers <em>r9-r15</em> and <em>r9-r15</em> can be used as temporary registers. This means they can be overwritten and these registers may not be preserved after a function call.</p>
<p>If the programmer wishes, registers that may be clobbered can be saved on the stack before a function call and restored after the call.</p>
<p>Callee-saved registers <em>r19-r28</em> are guaranteed to be preserved after a function call. Any function that uses these registers must save the values before use and restore the values before the function returns. These registers are called &quot;callee-saved&quot; because the onus is on the called function to preserve the values.</p>
<h2 id="memcopy-using-variables-on-the-stack"><a class="header" href="#memcopy-using-variables-on-the-stack">Memcopy using variables on the stack</a></h2>
<p>To illustrate how the stack can be used to store values local to a function we give you yet another version of the memcopy function. In this version we have the stack to hold the value for holding the index as we iterate over the elements and copy them.</p>
<pre><code class="language-armasm">
// Function to copy a string
memcopy_string:
    sub sp, sp, 48   // Adjust sp
    str x30, [sp]    // Save x30

    // Save arguments in stack
    str x0, [sp, 8]  // Save first argument in stack at (sp + #8)
    str x1, [sp, 16] // Save second argument in stack at (sp + #16)
    str x2, [sp, 24] // Save third argument in stack at (sp + #24)

    mov   x0, #0       // Initialize counter (local var)
    str   x0, [sp, 32] // Maintain counter in stack at (sp + #32)

copy_loop_start:
    ldr x0, [sp, 8]    // Load first argument from stack
    ldr x1, [sp, 16]   // Load second argument from stack
    ldr x2, [sp, 24]   // Load third argument from stack
    ldr x3, [sp, 32]   // Load local var counter from stack
    ldrb w4, [x0, x3]
    strb w4, [x1, x3]
    add  x3, x3, #0x1
    str  x3, [sp, 32]  // Save local var counter to stack
    cmp   w2, w3
    b.gt  copy_loop_start

    ldr x30, [sp]      // Restore x30
    add sp, sp, 48     // Adjust sp

    ret


// Helper function to find length of a string
find_string_length:
    sub sp, sp, 32 // Adjust sp
    str x30, [sp]  // Save x30
    str x0, [sp, 8]  // Save first argument

    ldrb  w5, [x0]
    cbz   w5, find_len_end

    mov   x0, #0         //  Initialize counter (local var)
    str   x0, [sp, 16]   //  Maintain counter in stack at (sp + #16)

    ldr   x0, [sp, 8]    // Load first argument from stack
find_len_start:
    ldr   x1, [sp, 16]   // Load counter from stack
    add   x1, x1, #0x1
    str   x1, [sp, 16]   // Save updated counter
    ldrb  w5, [x0, x1]
    cbnz  w5, find_len_start

find_len_end:
    ldr   x0, [sp, 16]   // Load counter(return value) from stack to x0

    ldr x30, [sp]        // Restore x30
    add sp, sp, 32       // Adjust sp

    ret

</code></pre>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make memcopy_stack.elf
RUN_COMMAND: make run
</code></pre>
<p>We have shown the above code as an example of how the stack can be used. It is <strong>NOT</strong> the ideal way to implement memcopy. The code below shows a more concise way to perform memcopy.</p>
<pre><code class="language-armasm">
// Function to copy a string
memcopy_string:
    sub sp, sp, 16  // Adjust sp
    str x30, [sp]   // Save x30

    mov   x3, #0x0
copy_loop_start:
    ldrb  w4, [x0, x3]
    strb  w4, [x1, x3]
    add   x3, x3, #0x1
    cmp   x2, x3
    b.gt  copy_loop_start

    ldr x30, [sp]   // Restore x30
    add sp, sp, 16  // Adjust sp

    ret


// Helper function to find length of a string
find_string_length:
    sub sp, sp, 16  // Adjust sp
    str x30, [sp]   // Save x30

    mov   x2, #0
    ldrb  w3, [x0, x2]
    cbz   w3, find_len_end
find_len_start:
    add   x2, x2, #0x1
    ldrb  w3, [x0, x2]
    cbnz  w3, find_len_start

find_len_end:
    mov x0, x2      // Move return value to x0

    ldr x30, [sp]   // Restore sp
    add sp, sp, 16  // Adjust sp

    ret

</code></pre>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make memcopy_optimized.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>Hrishi to explain general recursion here and what it involves.</p>
<pre><code class="language-armasm">    // Recursive function to Find sum of all integers smaller than or equal to given number using a recursive function.
    // For example, if given number is 4, the result would be 4+3+2+1 which is 10.
sum_of_n_recursive:
    stp x9, x30, [sp, -32]! // Save X30(link register) and a X19 (temporary register used as a local variable) onto the stack and adjust SP
    mov w9, w0              // Move the number passed as argument to temporary register
    cmp w0, 1               // Check if number is less that or equal to 1
    ble done                // Branch to label 'done' if we have completed adding all numbers till 1
    sub w0, w0, #1          // Subtract 1 from the number to perform a recursive call and obtain sum of all lower numbers
    bl  sum_of_n_recursive  // Perform a recursive call to obtain sum of all lower numbers
    add w0, w0, w9          // Add the resultant sum of all lower numbers with current number
done:
    ldp x9, x30, [sp], 32   // Restore back temporary register and X30 from stack
    ret                     // Return the result
</code></pre>
<p>This code is available in file exercises/functions/sum_of_n.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make sum_of_n.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="practice-exercises"><a class="header" href="#practice-exercises">Practice exercises</a></h2>
<h3 id="function-to-add-and-subtract-matrices"><a class="header" href="#function-to-add-and-subtract-matrices">Function to add and subtract matrices</a></h3>
<p>In the provided template write functions to</p>
<ul>
<li>add two matrices</li>
<li>subtract two matrices</li>
</ul>
<p>The address of the matrices and the destination matrix are parameters passed to the function via <em>x0</em>, <em>x1</em>, and <em>x2</em> registers. Register <em>x3</em> holds the dimension of square matrices. The result, which is the address of the destination matrix, should be returned in the <em>x0</em> register.</p>
<p>The files to be used for this exercise and the compile and run commands are given below:</p>
<ul>
<li>Matrix Addition:</li>
</ul>
<pre><code>    File to be used: exercises/functions/matrix_addition.s
    COMPILE_COMMAND: make matrix_addition.elf
    RUN_COMMAND: make run
</code></pre>
<ul>
<li>Matrix Subtraction:</li>
</ul>
<pre><code>    File to be used: exercises/functions/matrix_subtract.s
    COMPILE_COMMAND: make matrix_subtract.elf
    RUN_COMMAND: make run
</code></pre>
<h3 id="caesar-cipher"><a class="header" href="#caesar-cipher">Caesar Cipher</a></h3>
<p>Show a function that will take a shift value and a string to encrypt. The output should be a encrypted string.
For example, if input string is: &quot;Hello&quot; and shift value is '2', the expected encrypted string is: &quot;Jgnnq&quot;</p>
<p>As a challenge the user can write a decrypt function also to perform the reverse operation and print the original string.</p>
<p>For this exercise use the file exercises/functions/caesar_cipher.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make caesar_cipher.elf
RUN_COMMAND: make run
</code></pre>
<h3 id="recursive-function-to-compute-n"><a class="header" href="#recursive-function-to-compute-n">Recursive function to compute n!</a></h3>
<p>For this exercise use the file <em>exercises/functions/facorial.s</em>. In factorial.s, the number for which factorial will have to be computed is passed as argument to factorial_recursive function. Add code to compute the factorial using recursion and place the result in w0.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make factorial.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="what-we-learned-3"><a class="header" href="#what-we-learned-3">What we learned</a></h2>
<ul>
<li>Breaking down programs into functions</li>
<li>How parameters are passed into functions using registers</li>
<li>How values are returned from functions</li>
<li>Function recursion</li>
<li>A little bit of the ARM procedure call standard</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programming-in-c"><a class="header" href="#programming-in-c">Programming in C</a></h1>
<p>In previous chapters we learnt how to use AArch64 assembly language. Writing large programs in assembly can be tedious and most programs are written in higher-level languages like C/C++, Rust, Java, Kotlin, Swift etc. In this chapter we will learn the fundamentals of the C programming language.</p>
<p>The C programming language is considered a &quot;system programming language&quot;. It is used extensively in the development of operating systems and embedded systems. For example, most of the Linux kernel is written in C. Similarly, operating systems like OpenBSD, FreeBSD, NetBSD, and DragonFlyBSD all have large amounts of code written in the C language.</p>
<p>Programs written in high level languages are translated to assembly using special programs called compilers and assemblers. Two popular compilers for the C programming language are <strong>gcc</strong> and <strong>Clang</strong>. We will use a version of <strong>gcc</strong> that compiles C code to AArch64 assembly.</p>
<p>This chapter is a whirlwind tour of the C programming language. Readers will be introduced to commonly used portions of the C programming language and get to do some programming exercises for practice. The chapter will cover what is required to make progress for the rest of the book and will not be an in-depth tutorial in C programming.</p>
<hr />
<p>Readers already familiar with C may skip this chapter. Kindly note that we will continue to compile and execute code &quot;bare-metal&quot; meaning that there is no OS on the system. This means the standard C library is not used by the programming exercises in this book.</p>
<hr />
<h2 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h2>
<p>Let us start our journey with a simple program:</p>
<pre><code class="language-c">void main() {
  uart_puts(&quot;Hello World&quot;);
}
</code></pre>
<p>This program prints the text &quot;Hello World&quot; as output. You can compile and run it by:</p>
<ul>
<li>Change directory to exercises/c_functions/</li>
<li>make hello_world.elf (Compile)</li>
<li>make run (Run)</li>
</ul>
<p>Here is a quick summary of the hello world program. We will discuss specifics of functions and other syntax in later sections of this chapter.</p>
<ul>
<li>The first line of the program specifies the name of a function - <em>main</em>. All C programs must have a <em>main</em> function. Program execution will start at this function. The contents of functions are enclosed within curly brackets - { and }.</li>
<li>In <em>main</em> we call another function named <em>uart_puts</em> by passing it a value &quot;Hello World&quot;. The <em>uart_puts</em> function prints characters onto the screen. This function is defined in another file and when the program is compiled it is included in the compilation process.</li>
<li>All statements - like the function call to <em>uart_puts</em> - are ended with a semicolon</li>
</ul>
<p>Usually programs are developed to run on top of operating systems. In that case programmers can rely on standard libraries that will be available on most operating systems. These libraries will contain useful functions to print data on screen, read user input, read/write files etc. However, in this book all code that we write runs &quot;bare-metal&quot; meaning there is no underlying operating system or standard libraries to rely on. The <em>uart_puts</em> function is not part of the code written to support this book. We will learn how it works in later chapters.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-constants-and-data-types"><a class="header" href="#variables-constants-and-data-types">Variables, Constants and Data types</a></h1>
<p>In any program we need to be able to hold data for processing. In  assembly we used registers and memory (stack) to store data. When programming in higher level languages the programmer can use labels called &quot;variables&quot; to hold data. The variable name is a convenient way to refer to the data which may be stored in registers or in memory.</p>
<p>Variable names are made of letters and digits, but the first character of the name <strong>must</strong> be a letter. For the purpose of variables the underscore character &quot;_&quot; counts as a letter. Here  are examples of valid variable names: <em>employee_name</em>, <em>car_speed</em>, <em>num_of_forks</em>, <em>table9</em> etc. Variable names are case sensitive so a variable named <em>x</em> is different from <em>X</em>. The general C programming convention is to use lower case names and separate words using underscore. However, this is not a requirement.</p>
<p>Variable names have to be unique within the same scope. So we cannot have more than one variable named <em>score</em> in our function because it would be impossible to say which <em>score</em> we are referring to at different points in the code. Scope will be explained later in this chapter.</p>
<p>Though underscore counts as a character <strong>do not</strong> begin variable names with it. Library routines, consisting of helpful pre-written code, quite often use variable names beginning with underscore.</p>
<p>When we define a variable in our program we are telling the compiler to allocate a specific amount of memory. We refer to that memory location in our program using the variable name. Here is an example of a variable definition:</p>
<pre><code class="language-c">void main() {   //beginning of the main function
  int count;    //a variable named count should be given the space allocated to an integer
  count = 45;   //write a value to count
}               //end of the main function
</code></pre>
<p>Lets break down the three lines above. The line defining <em>count</em> asks the compiler to reserve memory that corresponds to an &quot;integer&quot; and assign it the label <em>count</em>. In the remainder of  <em>main()</em> we can refer to this memory location using its label (i.e. variable name).</p>
<p>The <em>count</em> above is defined to be an integer. What other data types are supported in C:</p>
<ul>
<li><em>char</em> : a single byte of data capable of holding one ASCII<sup>1</sup> character</li>
<li><em>int</em> : positive and negative whole numbers including 0</li>
<li><em>float</em> : single precision floating point numbers</li>
<li><em>double</em> : double precision floating point numbers</li>
</ul>
<p>The <em>float</em> and <em>double</em> data types are used to store rational numbers (e.g. 1.2, 3.414 etc). We have not discussed how computers represent rational numbers and related assembly instructions. That is out of the scope of the material in this book. We may use some rational numbers in our C programming examples. Such numbers will be stored in variables of <em>float</em> or <em>double</em> type.</p>
<p>So we know <code>int count;</code> reserves enough memory to hold an integer but how much is that? The actual number of bytes that <em>int</em> represents is architecture dependent. In AArch64 an <em>int</em> is 4 bytes (i.e. 32 bits). Incidentally it is the same size on the other popular architecture - X86. The size of different types of variables in C on AArch64 is documented in the <a href="https://developer.arm.com/documentation/den0024/a/Porting-to-A64/Data-types">ARM Cortex-A Series Programmer's Guide</a>.</p>
<p>In addition to types variables may, optionally, have additional qualifiers. Two qualifiers - <em>short</em> and <em>long</em> - can control the size of a <em>int</em> type variable when it is defined.</p>
<pre><code class="language-c">short int x;      // a 16-bit integer
short y;          // same as above; can skip int
long int a;       // a 32-bit integer
int b;            // same as long int
long c;           // same as long int
long long int d;  // a 64-bit integer
long long e;      // same as long long int

float k;          // a 32-bit floating point number
double l;         // a 64-bit floating point number
</code></pre>
<p>Another two qualifiers - <em>signed</em> and <em>unsigned</em> - can be used to specify if an <em>int</em> or <em>char</em> variable holds signed numbers or unsigned numbers. An <em>unsigned char</em> variable is 8 bits in size and can hold values from 0 to 2<sup>8</sup>-1. A <em>signed char</em> is also 8-bits long. It can hold values between -128 (i.e. -2<sup>7</sup>) to 127 (i.e. 2<sup>7</sup>-1). This should be no surprise to you as we covered binary representation in a <a href="./binary_representation.html">previous chapter</a>.</p>
<pre><code class="language-c">int z;            // signed integer
signed int z;     // signed integer
unsigned int b;   // unsigned integer

char x;           // signed char
signed char y;    // signed char
unsigned char c;  // unsigned char  

int l,m,n;        // defining 3 variables l, m, and n in one line
</code></pre>
<p>Variables are labels to memory locations. In our programs, once we define them, we can assign values to them, and also overwrite existing values by assigning the variable a new value. All variables must be declared before use. A declaration specifies the type of the variable (therefore it's size in memory) and the name of the variable. Variables may be optionally initialized at the time of declaration. It is considered good programming practice to initialize variables.</p>
<pre><code class="language-c">int x = 5;

x = 7;

x = 11;
</code></pre>
<p>It is important to remember that the code in a C program is not direct instructions to the processor. The code is first read by a compiler which in turn generates the assembly code (and machine code) that will be executed on the processor. So, when we define a variable we are instructing the compiler to reserve space of a clearly defined size to hold our data. The compiler can decide whether that reservation will be in memory or register. By defining a variable we are also telling the complier that within a certain program scope (we will discuss scope later) that memory location will be referred to by the variable name.</p>
<BR>
<hr />
<p><sup>1</sup>ASCII (American Standard Code for Information Interchange) is a character encoding format to represent text data in computers. In this format one byte of data can be used to represent a character.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-language-syntax"><a class="header" href="#c-language-syntax">C Language Syntax</a></h1>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<p>In the C programming language large programs can be organized into smaller, reusable blocks of code called functions. The one C function all programs <strong>must</strong> have is the <em>main</em> function. This is where every program starts execution. </p>
<p>The syntax of a function is <code>return_type function_name( parameters ) { /* Code inside function */ }</code>. The return type must be a standard C data type or a struct or enum (we will cover them later). If the function returns no value then the return type must be specified as <em>void</em>. In the event no return type is specified then the compiler assumes it to be <em>int</em>. The code inside a function is contained within curly braces.</p>
<p>Examples of functions:</p>
<pre><code class="language-c">// These are examples of functions not a full working program. 
// That is why there is no main().

void function1() {
  int x = 2;
  char y = 'i';
  uart_puts(&quot;Value of x is: &quot;);
  uart_print_num(x);
  uart_puts(&quot;Value of y is: &quot;);
  uart_puts(y);
}

// A function that takes an integer parameter, increments it by 1 and
// returns the result as an integer

int addOneToThis(int x) {
  return x + 1;
}

void example_fn() {
  int d = 2;
  int f = addOneToThis(d);
  uart_puts(&quot;Value of f is: &quot;);
  uart_print_num(f);
}
</code></pre>
<p>All functions have a name that is used to call the function. Functions can optionally take parameters. In the example above <em>function1</em> does not take parameters. The return type of the function is <em>void</em> meaning that it does not return any value.  This is a simple function that takes no value and returns no value. It merely prints an integer and a character by making calls to appropriate print functions. Note that we use <strong>two different functions</strong> to print strings and integers. </p>
<p>The function <em>addOneToThis</em> takes one integer parameter (also called <em>argument</em>) and returns an integer value. This function can be called from any other function by passing an integer value as the argument. The third function <em>example_fn</em> also takes no parameters and does not return any value. It calls <code>addOneTothis(int)</code>.</p>
<p>The variables that are defined inside a function are local to that function and available only inside the function. This includes any parameters that are passed to the function. In the code above the <em>integer</em> variable <em>x</em> in <em>function1</em> is local to the function and cannot be accessed by any other function including <em>main</em>. When <em>uart_print_num</em> is called a <strong>copy</strong> of the contents of <em>x</em> are passed to it as a parameter.</p>
<p>Similarly, in the case of <em>example_fn</em> the variable <em>d</em> and <em>f</em> are visible only inside the function. They are not accessible from any other function including <em>addOneToThis</em>. We pass a copy of <em>d</em> to <em>addOneToThis</em> through its parameter named <em>x</em>. When <em>x</em> is changed inside <em>addOneToThis</em> it does not alter the value of <em>d</em> in <em>example_fn</em>. The local copy of <em>d</em>, passed as a parameter, is the one that is modified. The modified value of <em>x</em> is returned by <em>addOneToThis</em>. A copy of the returned value is saved in <em>f</em> in <em>example_fn</em>. Furthermore, any variable that is defined inside <code>{ }</code> is local to the code within the braces.</p>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<p>The C programming language has the following operators:</p>
<table><thead><tr><th>Arithmetic</th><th></th><th>Relational and Logical</th><th></th></tr></thead><tbody>
<tr><td><strong>Operator</strong></td><td><strong>Operation</strong></td><td><strong>Operator</strong></td><td><strong>Operation</strong></td></tr>
<tr><td>+</td><td>addition</td><td>&gt;</td><td>greater than</td></tr>
<tr><td>-</td><td>subtraction</td><td>&gt;=</td><td>greater than or equal to</td></tr>
<tr><td>*</td><td>multiplication</td><td>&lt;</td><td>less than</td></tr>
<tr><td>/</td><td>division</td><td>&lt;=</td><td>less than or equal to</td></tr>
<tr><td>%</td><td>modulus</td><td>==</td><td>is equal to</td></tr>
<tr><td>++</td><td>increment</td><td>!=</td><td>is not equal to</td></tr>
<tr><td>--</td><td>decrement</td><td></td><td></td></tr>
</tbody></table>
<p>We have already used the <em>add</em> operator in the example above. That operator takes two <em>integers</em> (or <em>floats</em>) and the expression returns a value of the same type. All arithmetic operators other than <em>increment</em> and <em>decrement</em> work the same way as <em>add</em>.</p>
<p>The <em>increment</em> and <em>decrement</em> operators need only one input. They increase or decrease the value of that variable by 1.</p>
<pre><code class="language-c">// A version with increment operator
int addOneToThis(int x) {
  return x++;
}
</code></pre>
<p>The <em>increment</em> and <em>decrement</em> operators can be used as pre-fix or post-fix operators. The example below shows the difference:</p>
<pre><code class="language-c">
void preFixPostFixExample() {
  int x = 2;

  //pre-fix increment
  int y = ++x; // increment the value of x then store in y

  uart_puts(&quot;Value of y is: &quot;);
  uart_print_num(y); // y = 3
  uart_puts(&quot;Value of x is: &quot;);
  uart_print_num(x); // x = 3

  // post-fix decrement
  y = x--;
  uart_puts(&quot;Value of y is: &quot;);
  uart_print_num(y); // y = 3
  uart_puts(&quot;Value of x is: &quot;);
  uart_print_num(x); // x = 2
}
</code></pre>
<p>This code is available in file exercises/c_functions/prefix_postfix_example.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make prefix_postfix_example.elf
RUN_COMMAND: make run
EXPECTED_OUTPUT : 
Value of y is:
3
Value of x is:
3
Value of y is:
3
Value of x is:
2
</code></pre>
<h2 id="expressions-and-statements"><a class="header" href="#expressions-and-statements">Expressions and statements</a></h2>
<p>In the C programming language an <em>expression</em> is a combination of operands and operators. Expressions typically return a value. Here are examples of expressions:</p>
<pre><code class="language-c">x + 1

y &lt; 5

a == b

3 + f * 2

g = 0  //This is an assignment expression and it returns the value assigned to g

</code></pre>
<p>An <em>expression</em> becomes a <em>statement</em> when it is terminated by a semi-colon. Examples:</p>
<pre><code class="language-c">x + 1;

y &lt; 5;

a == b;

3 + f * 2;

g = 0;
</code></pre>
<p>Of course variables have to be declared before use in <em>expressions</em> or <em>statements</em>. For example:</p>
<pre><code class="language-c">int x;
int j;
</code></pre>
<p>Curly braces (i.e. { }) are used to group declarations (i.e. int x;) and statements together into a <em>block</em>. Blocks do not have to be terminated by a semi-colon. Variables can be declared inside any block and their <em>scope</em> will be limited to the corresponding block. We will discuss scope of variables later in this section.</p>
<h2 id="control-flow"><a class="header" href="#control-flow">Control flow</a></h2>
<p>Control flow syntax can be used to selectively execute code or execute a certain section of code multiple times.</p>
<h2 id="if-else"><a class="header" href="#if-else">If-else</a></h2>
<p><em>if-else</em> expressions are used to selectively execute code if specific conditions are met. In an <em>if-else</em> pair only the <em>if-block</em> or the <em>else-block</em> will be executed. For example:</p>
<pre><code class="language-c">// function returns the lower of two integers
int find_lower_int(int x, int y) {
  if (x &lt;= y) {
    // if the value of x is less than or equal to y
    // execute the code in this block
    return x;
  } else {
    // if the condition above is false
    // execute code in this block
    return y;
  }
}

int main()
{
    int lower_int_val = find_lower_int(2, 6);
    uart_print_num(lower_int_val);
}

</code></pre>
<p>This code is available in file exercises/c_functions/if_else_example.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make if_else_example.elf
RUN_COMMAND: make run
EXPECTED_OUTPUT : 2
</code></pre>
<p>The condition being evaluated by the if block can be a variable or a expression. The <em>if-block</em> is executed if the variable is non-zero (of the expression evaluates to a non-zero value). Note that the <em>else-block</em> is completely optional. If the block is not present nothing is executed if the expression is 0. The program just moves on to the next line of code.</p>
<h3 id="loops"><a class="header" href="#loops">Loops</a></h3>
<p>There are three types of loops in the C language:</p>
<ul>
<li>for loop</li>
<li>while loop</li>
<li>do while loop</li>
</ul>
<p>The general form of the <em>for</em> loop is shown below:</p>
<pre><code>for (expr1; expr2; expr3) {
  /* loop code */
}
</code></pre>
<p>The loop syntax has three <em>expressions</em> - <em>expr1</em> is the initial expression that is executed just once. The expression <em>expr2</em> is a loop termination condition and is executed at the beginning of every iteration of the loop. The final <em>expr3</em> typically changes variables that count the current iteration of the loop. Below is a specific example:</p>
<pre><code class="language-c">void main() {
  int i;
  for(i = 0; i &lt; 5; i++) {
    uart_puts(&quot;Value of i: &quot;);
    uart_print_num(i);
  }

  uart_puts(&quot;After the loop i is:&quot;);
  uart_print_num(i);
}
</code></pre>
<p>This code is available in file exercises/c_functions/for_loop_example.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make for_loop_example.elf
RUN_COMMAND: make run
EXPECTED_OUTPUT : 
Value of i:
0
Value of i:
1
Value of i:
2
Value of i:
3
Value of i:
4
After the loop i is:
5
</code></pre>
<p>In this loop the loop control variable <em>i</em> is first set to 0 - this is the first expression in the <em>for</em> statement. The value of this variable determines when the loop will end. The second expression in the statement is <em>i &lt; 5</em>. As long as this expression evaluates to a non-zero value (true) the loop will execute another iteration. The third expression - <em>i++</em> - is code that will be executed as part of the loop.</p>
<p>At the start of the loop <em>i = 0</em> is executed <strong>once</strong> and the value of the loop control variable (<em>i</em>) is set to 0. This expression is not executed after the first time (i.e. in any iteration of the loop).</p>
<p>The second expression - <em>i &lt; 5</em> - is executed at the beginning of every iteration of the loop. If the expression evaluates to <em>true</em> then the loop contents are executed. If not, control flow jumps to the code after the loop. The last expression - <em>i++</em> - increments the control variable and is executed as though it is part of the loop code. The <em>for</em> loop code will print:</p>
<pre><code>Value of i:
0
Value of i:
1
Value of i:
2
Value of i:
3
Value of i:
4
After the loop i is:
5
</code></pre>
<p>In the first 5 iterations the value of <em>i</em> will be incremented by 1 during every iteration. So it will go from 0 till 4. As part of the code executing in the 5th iteration the value of <em>i</em> will be incremented to 5. At the beginning of the 6th iteration the comparison <em>i &lt; 5</em> will evaluate to 0 (false). So the loop contents are skipped and the remaining statements of code are executed.</p>
<p>Another type of loop is the <em>while</em> loop. The general form of the while loop is:</p>
<pre><code class="language-c">while (expr1) {
  /*loop code*/
}
</code></pre>
<p>This loop is executed as long as the expression expr1 evaluates to a non-zero value (i.e. true). The expression can be any legal expression in the C programming language. Usually it will involve a relational/logical operator. This while-loop example gives the same result as the for-loop example above:</p>
<pre><code class="language-c">void main() {
  int i= 0;

  while(i &lt; 5) {
    uart_puts(&quot;Value of i: &quot;);
    uart_print_num(i);
    i++;
  }

  uart_puts(&quot;After the loop i is:&quot;);
  uart_print_num(i);
}
</code></pre>
<p>This code is available in file exercises/c_functions/while_loop_example.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make while_loop_example.elf
RUN_COMMAND: make run
EXPECTED_OUTPUT:
Value of i:
0
Value of i:
1
Value of i:
2
Value of i:
3
Value of i:
4
After the loop i is:
5
</code></pre>
<p>In both the above loop constructs the loop termination condition is checked at the start of the loop. This means if the condition is not satisfied when the first iteration of the loop is encountered then the loop may be skipped. For example, in the while-loop code above if we initialize the value of <em>i</em> to be 5 or greater then the loop contents will not get executed.</p>
<p>In the do-while loop the termination condition is checked at the end of the loop. Here is an example:</p>
<pre><code class="language-c">void main() {
  int i= 0;

  do {
    uart_puts(&quot;Value of i: &quot;);
    uart_print_num(i);
    i++;
  } while(i &lt; 5);

  uart_puts(&quot;After the loop i is:&quot;);
  uart_print_num(i);
}
</code></pre>
<p>This code is available in file exercises/c_functions/do_while_loop_example.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make do_while_loop_example.elf
RUN_COMMAND: make run
EXPECTED_OUTPUT :
Value of i:
0
Value of i:
1
Value of i:
2
Value of i:
3
Value of i:
4
After the loop i is:
5
</code></pre>
<p>The above code also prints the same output as the previous loops. However, this loop will get executed at least once. So even if we set the initial value of <em>i</em> to something greater than 5 the loop will still be executed once - because the condition is checked at the end of the loop.</p>
<h3 id="break-and-continue"><a class="header" href="#break-and-continue">break and continue</a></h3>
<p>Sometimes we may want to end a loop earlier than the control expression allows us to. This can be done using the <strong>break</strong> statement. Here is a modified version of the <em>do-while</em> example:</p>
<pre><code class="language-c">void main() {
  int i= 0;

  do {
    if (i &gt; 4)
      break;

    uart_puts(&quot;Value of i: &quot;);
    uart_print_num(i);
    i++;
  } while(i &lt; 5);

  uart_puts(&quot;After the loop i is:&quot;);
  uart_print_num(i);
}
</code></pre>
<p>This code is available in file exercises/c_functions/break_example.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make break_example.elf
RUN_COMMAND: make run
EXPECTED_OUTPUT :
Value of i:
0
Value of i:
1
Value of i:
2
Value of i:
3
Value of i:
4
After the loop i is:
5
</code></pre>
<p>The above code gives the same output at the previous loops. However, unlike in the previous <em>do-while</em> loop, if the initial value of <em>i</em> is set greater than 4 it will enter the loop and exit it at the <em>break</em> statement without executing the remaining iterations. Couple of things to note in the code above -</p>
<ol>
<li>We can use an if-statement without an else. If the condition is satisfied the contents of the if-block are executed. If the condition is not satisfied those contents are skipped over.</li>
<li>There are no curly braces enclosing the contents of the if-statement. In the event we have only one statement to put inside an if-statement we can skip the braces. Same holds for for- and while-statements.</li>
</ol>
<p>Sometimes we may want to skip an iteration of the loop based on a condition and not exit the loop completely. In the example below we print only even numbers:</p>
<pre><code class="language-c">void main() {
  int i;
  for(i = 0; i &lt; 10; i++) {
    if (i % 2 != 0)
      continue;

    uart_puts(&quot;Value of i: &quot;);
    uart_print_num(i);
  }

  uart_puts(&quot;After the loop i is:&quot;);
  uart_print_num(i);
}
</code></pre>
<p>This code is available in file exercises/c_functions/continue_example.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make continue_example.elf
RUN_COMMAND: make run
EXPECTED_OUTPUT:
Value of i:
0
Value of i:
2
Value of i:
4
Value of i:
6
Value of i:
8
After the loop i is:
10
</code></pre>
<p>The first code statement inside the loop checks to see if <em>i</em> is perfectly divisible by 2. All even numbers, as you know, can be divided by 2 leaving no remainder. The mod operator (%) divides the first number by the second and returns the remainder. We check if that value <strong>does not equal 0</strong>. If the condition is true that means <em>i</em> is a odd number and we use <em>continue</em> to go back to the start of the loop and execute the next iteration.</p>
<p>While using loops programmers should be careful to ensure that the loop termination condition will be met eventually. If that condition is not met then the loop will never exit and the program will run for ever. It is pretty easy to get into trouble like that when copy-pasting code :-). For example, here is the code to print even numbers. But it has a bug that makes the loop an infinite loop. Can you find the error and how to fix it?</p>
<pre><code class="language-c">void main() {
  int i= 0;

  while(i &lt; 10) {

    //This works for the for-loop so let me paste it here.
    if (i % 2 != 0)
      continue;

    uart_puts(&quot;Value of i: &quot;);
    uart_print_num(i);
    i++;
  }

  uart_puts(&quot;After the loop i is:&quot;);
  uart_print_num(i);
}
</code></pre>
<details>
  <summary>Try solving it your self  first and then click here to see answer.</summary>
<pre><code class="language-c">void main() {
  int i= 0;

  while(i &lt; 10) {
    if (i % 2 != 0) {
      i++;
      continue;
    }
    uart_puts(&quot;Value of i: &quot;);
    uart_print_num(i);
    i++;
  }

  uart_puts(&quot;After the loop i is:&quot;);
  uart_print_num(i);
}
</code></pre>
</details>
<h3 id="switch"><a class="header" href="#switch">Switch</a></h3>
<p>The <em>switch</em> statement is another way in which a decision can be made on which code section will be executed. The general form of the <em>switch</em> statement is:</p>
<pre><code class="language-c">switch (expression) {
  case constant-expression1: code
  case constant-expression2: code
  default: code
}
</code></pre>
<p>The way <em>swtich</em> works is that if <em>expression</em> matches any of the expressions in a case statement then the code corresponding to the  matching case statements are executed.</p>
<p>Here is an example of using the <em>switch</em> statement:</p>
<pre><code class="language-c">void main() {
  int x = 25;

  switch x {
    case 5:
      uart_puts(&quot;X is 5&quot;);
      break;
    case 10:
    case 15:
      uart_puts(&quot;X is 10 or 15&quot;);
      break;
    case 25:
      uart_puts(&quot;X is 25&quot;);
      break;
    default:
      uart_puts(&quot;I dont know what X is...&quot;);
      break;
  }
}
</code></pre>
<p>This code is available in file exercises/c_functions/switch_example.s.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make switch_example.elf
RUN_COMMAND: make run
EXPECTED_OUTPUT : X is 25
</code></pre>
<p>Some things to be aware of regarding <em>switch</em>:</p>
<ul>
<li>If we want the same code to execute for two different cases then place them right next to each other like <em>case 10</em> and <em>case 15</em> above.</li>
<li>The code fragments of each case has to end with a <em>break</em> statement to exit the <em>switch</em>. If not, matching with other <em>case</em> statements will continue.</li>
<li><em>default</em> will match if no other <em>case</em> matches. However, it is optional. If omitted and the given expression does not match any <em>case</em> then none of the code statements inside the <em>switch</em> will be executed.</li>
</ul>
<p>Note that almost everything that can be done with <em>switch</em> statement can also be accomplished using <em>if-else</em>. But there may be times when one form is preferable over the other for conciseness or readability. fff</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>We covered a lot of C programming language syntax in this section. While we have not covered all of the language this should be sufficient for the reader to tackle the programming exercises in the next section. We will cover additional bits of the language as and when we need to use them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c-programming-exercises"><a class="header" href="#c-programming-exercises">C Programming Exercises</a></h1>
<p>Here are some programming exercises for you to try. Just like in previous exercises, try to complete it yourself before looking at the solution.</p>
<h2 id="count-leading-zeros-loops-integer-data-types"><a class="header" href="#count-leading-zeros-loops-integer-data-types">Count leading zeros (Loops, Integer data types)</a></h2>
<p>The objective of this exercise is to count the number of 1s in the binary representation of an integer.</p>
<p>File to be used for this exercise is : exercises/c_functions/count_leading_zeros.c. This file provides following skeleton. You will have to add code to count the number of leading zeros in variable 'integer_value' and place the result in variable 'count'.</p>
<pre><code class="language-c">
int count_leading_zeros(unsigned int integer_value)
{
    // Initialize count to zero
    int count = 0;

    // Your code starts here

    // Your function should count the number of leading zeros in variable 'integer_value'
    // and place the result in variable 'count'

    // Your code ends here

    // Return the count value
    return count;
}

void main()
{
    int result = 0;
    unsigned int num = 0x0000FFFF;

    // Count the number of leading zeros on unsigned int 'num' and store the result in variable 'result'
    // A leading zero is any 0 digit that comes before the first nonzero digit in a number's binary form

    // Your function called here
    result = count_leading_zeros(num);


    uart_print_num(result);
}

</code></pre>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make count_leading_zeros.elf
RUN_COMMAND: make run
</code></pre>
<p><strong>Pseudo code</strong>:</p>
<ol>
<li>Initialize count to zero</li>
<li>Some kind of loop start. Determine what should be the loop termination condition?
Hint: Unisgned bit has 32 bits</li>
<li>Keep left shifting the provided integer value by '1'</li>
<li>Check if the leftmost bit is '1' or '0'
Hint: Which logical operation can be used for this? You can refer to &quot;Logical operations&quot; section in section 6.2 </li>
<li>Increment the count value if the leftmost bit is '0' and go to start of the loop started in step 2</li>
<li>Exit the loop if the the leftmost bit is '1'</li>
<li>Return the count value</li>
</ol>
<p>A sample implementation of the above pseudo code is available in count_leading_zeros_solution.c file. </p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make count_leading_zeros_solution.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="factorial-loops-multiplication"><a class="header" href="#factorial-loops-multiplication">Factorial (Loops, multiplication)</a></h2>
<p>In this exercise we will compute the factorial of a number. Factorial value of a number 'N' is multiplication of all integers smaller than or equal to 'N'. For example 4! (four factorial) = 4 * 3 * 2 * 1.</p>
<p>File to be used for this exercise is : exercises/c_functions/factorial.c. This file provides following skeleton. You will have to add code to compute factorial and place the result in variable 'factorial_val'.</p>
<pre><code class="language-c">unsigned int factorial(unsigned int n)
{
    //This function take a paramenter n and returns n!

    int i;

    // Initialize factorial_val to 1
    int factorial_val = 1;

    // Your code starts here

    // Your code ends here

    // Return the factorial value 'factorial_val'
    return factorial_val;
}

void main()
{
    unsigned int result = 0;
    unsigned int num = 5;

    // Find the factorial of given number 'num' and store the result in variable 'result'
    // Factorial value is multiplication of all integers smaller than or equal to given number. For example factorial of 4 is 4*3*2*1 which is 24.

    // Your function called here
    result = factorial(num);

    uart_print_num(result);
}
</code></pre>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make factorial.elf
RUN_COMMAND: make run
</code></pre>
<p><strong>Pseudo code</strong>:</p>
<ol>
<li>Declare a variable to compute factorial(say factorial_val) and initialize it to 1</li>
<li>Some kind of loop to iterate a variable(say i) through values from 2 to n-1 (where 'n' is argument to function)</li>
<li>Multiply current number(i) with the product in factorial_val in each iteration of the loop</li>
<li>Return the factorial value 'factorial_val' after the end of the loop</li>
</ol>
<p>A sample implementation of the above pseudo code is available in factorial_solution.c file. </p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make factorial_solution.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="factorial-recursive-variant-recursion"><a class="header" href="#factorial-recursive-variant-recursion">Factorial recursive variant (Recursion)</a></h2>
<p>In this exercise we will compute the factorial of a number using recursion. Factorial value of a number 'N' is multiplication of all integers smaller than or equal to 'N'.</p>
<p>File to be used for this exercise is : exercises/c_functions/factorial_recursive.c. This file provides following skeleton. You will have to add code to compute factorial using recursion.</p>
<pre><code class="language-c">unsigned int factorial_recursive(unsigned int n)
{
    // Your code starts here

    // Your code ends here
}

void main()
{
    unsigned int result = 0;
    unsigned int num = 5;

    // Find the factorial of given number 'num' and store the result in variable 'result'
    // Factorial value is multiplication of all integers smaller than or equal to given number. For example factorial of 4 is 4*3*2*1 which is 24.

    // Your function called here
    result = factorial_recursive(num);

    uart_print_num(result);
}
</code></pre>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make factorial_recursive.elf
RUN_COMMAND: make run
</code></pre>
<p><strong>Pseudo code</strong>:</p>
<ol>
<li>Return 1 if value of 'n'(argument to function) is either 0 or 1</li>
<li>If the value is greater than 1, perform a recursive call to the same function with (n - 1) value as argument</li>
<li>Multiply the result returned by recursive call in step 2, with 'n'</li>
<li>Return the result obtained by step 3</li>
</ol>
<p>A sample implementation of the above pseudo code is available in factorial_recursive_solution.c file. </p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make factorial_recursive_solution.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="reverse-a-number-modulo-operator"><a class="header" href="#reverse-a-number-modulo-operator">Reverse a number (Modulo operator)</a></h2>
<p>The objective of this exercise is to reverse the digits of a decimal number.</p>
<p>File to be used for this exercise is : exercises/c_functions/reverse_num.c. This file provides following skeleton. You will have to add function to reverse the digits of provided number.</p>
<pre><code class="language-c">void main()
{
    unsigned int result = 0;
    unsigned int num = 13579;

    // Reverse the digits of a given number 'num' and store the result in variable 'result'
    // For example: if given number is = 13579 Output: 97531

    // Your function called here
    result = reverse_num(num);

    uart_print_num(result);
}
</code></pre>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make reverse_num.elf
RUN_COMMAND: make run
</code></pre>
<p><strong>Pseudo code</strong>:</p>
<ol>
<li>Initialize a variable (say reverse_num) with value 0</li>
<li>Some kind of loop that will exit only when the value of 'num' (argument to function) becomes less than or equal to '0'</li>
<li>Multiply the 'reverse_num' by 10 and then add remainder value obtained by dividing 'num' by 10</li>
<li>Divide the 'num' by 10</li>
<li>Return 'reverse_num'</li>
</ol>
<p>A sample implementation of the above pseudo code is available in reverse_num_solution.c file. </p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make reverse_num_solution.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="print-number-of-days-in-a-month-switchcase"><a class="header" href="#print-number-of-days-in-a-month-switchcase">Print number of days in a month (Switch/Case)</a></h2>
<p>The objective of this exercise is to find number of days in given month number using switch statement. For example, if the value is 2, it means February and 12 means December</p>
<p>File to be used for this exercise is : exercises/c_functions/print_num_days_in_month.c. This file provides following skeleton. You will have to add a function to find the number of days in given month.</p>
<pre><code class="language-c">void main()
{
    int result = 0;
    unsigned int month_num = 5;

    // Find number of days in given month number 'month_num' and store the result in variable 'result'
    // For ex: If the value in register x0 is 1, then it means January, 2 means February .. 12 means December

    // Your function called here
    result = find_num_days_in_month(month_num);

    uart_print_num(result);
}
</code></pre>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make print_num_days_in_month.elf
RUN_COMMAND: make run
</code></pre>
<p><strong>Pseudo code</strong>:</p>
<ol>
<li>Make use a switch statement ( introduced in section 10.2 C language syntax) to test the value passed as argument (say month_num)</li>
<li>If the value of month number (month_num) is greater than 12, print an error message that an invalid month number has been passed</li>
<li>If the month number (month_num) is one out of 1, 3, 5, 7, 10 or 12, return result as 31 Days</li>
<li>If the month number(month_num) is one out of 4, 6, 9 or 11 return result as 30 Days</li>
<li>Return 28 Days, if month_num does not match condition in (3) or (4) conditions</li>
</ol>
<p>A sample implementation of the above pseudo code is available in print_num_days_in_month_solution.c file. </p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make print_num_days_in_month_solution.elf
RUN_COMMAND: make run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="introduction-to-arrays-and-pointers-in-c"><a class="header" href="#introduction-to-arrays-and-pointers-in-c">Introduction to Arrays and Pointers in C</a></h1>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>Quite often it is useful to group data into contiguous locations in memory. For example, say we are writing a program to compute the average temperature of a city. The data we are given is the daily temperature measured at noon.</p>
<p>Below is a function that computes the average:</p>
<pre><code class="language-c">int avg_temp(int temp1, int temp2, int temp3) {
  return (temp1 + temp2 + temp3)/3;
}
</code></pre>
<p>But as you can see the function takes only three inputs. If we want to add another day to the average we have to re-write the function to take an additional parameter. A fifth data again requires change to the code.</p>
<p>One way to solve this problem (of having to keep changing code) is to group the temperature data into an <strong>array</strong> of integers. Here is how a int array is defined. We can optionally also specify the number of elements in the array. In the first example below the compiler figures out that the array has 5 integer elements. In the second example we explicitly tell the compiler we want an array of 4 elements and also specify the data.</p>
<pre><code class="language-c">//Temp in centigrade. We ignore fractions and hold only whole numbers in this example.
//Pretending we are in a nice place.
int temps[] = {25, 23, 27, 22, 26};

int scores[4] = {5, 9, 7, 2}
</code></pre>
<p>The individual elements of the array can be accessed like this:</p>
<pre><code class="language-c">temps[0]; // first element of the temps array from above
temps[4]; // last element of the temps array
uart_print_num(temps[2]); // print the third element
</code></pre>
<p>We can now rewrite the above function to take an integer array and a number specifiying the size of the array.</p>
<pre><code class="language-c">int avg_temp(int temps[], int size) {
  int sum = 0;
  for (int i = 0; i &lt; size; i++ ) {
    sum += temps[i];
  }
  return sum/size;
}
</code></pre>
<p>In the function above we used the syntax -  <code>avg_temp(int temps[], int size)</code> - this means that the function takes two parameters, an integer array and an integer. The actual number of elements in the array does not have to be specified as part of the array parameter. It is possible to access array elements beyond the last element in the array. However, one should not do that by design because we could be accessing memory of another variable. So the programmer has to keep track of the array length and ensure array access are within bounds. Accessing beyond the array bounds can lead to bugs (including serious security bugs) and crashes.</p>
<pre><code class="language-c">int scores[4] = {5, 9, 7, 2}
</code></pre>
<p>When an array is defined like <em>scores</em> above, the compiler sets aside memory to hold the specified amount of memory. In this case we are asking for memory to hold <strong>four</strong> <strong>integers</strong>. Integers are 32-bits (8 bytes), so the compiler sets aside 32 bytes of memory to hold the array. These integers are can be refered to as - scores[0], scores[1], scores[2], and scores[3]. Note that if the array has N elements, the index of the last element is N-1. The allocated memory is contiguous, meaning scores[0] is immediately followed by scores[1], which is immediately followed by scores[2] and so on.</p>
<p>The label assigned to the array (in this case <em>scores</em>) points to the memory location that is the start of the array. To this label the index times the size of the element is added to access individual elements. So when the programmer writes <em>scores[0]</em> the address of the first element is computed as the address pointed to by <em>scores</em> + 0 * size of an integer (i.e. 8 bytes). Similarly, the address of <em>scores[3]</em> = address of <em>scores</em> + 3 * 8.</p>
<p>We use <em>typed variables</em> in C to hold data. In a previous chapter we discussed the different types that are available to C programmers. Arrays are also typed and all values in the array are of the same type. In the example above we used an array of <em>int</em>. Since the size of an <em>int</em> is 8 bytes the compiler knows to scale the index by 8 when we index into the <em>scores</em> array.</p>
<p>Similar to <em>int</em> arrays we can create arrays of any type in C. Strings in C are a special type of <em>char</em> arrays. The difference between a regular character array and a string is that the last entry of a string is a special character - '\0'. Here is an example of a char array:</p>
<pre><code class="language-c">char name[] = &quot;Suraj&quot;;  

//The above statement allocates 6 bytes in memory to hold the characters.
</code></pre>
<p>When we define a character array like above the C compiler interprets that as a request for a <strong>string</strong>. So it automatically allocates one byte more than the total length of characters we have defined. The additional space is used to store the string termination character. So in reality the characters stored are - 'S', 'u', 'r', 'a', 'j', and '\0'.</p>
<h3 id="2d-arrays"><a class="header" href="#2d-arrays">2D arrays</a></h3>
<p>The arrays that considered up to this point are one-dimensional(1D) arrays (a single dimension of elements). Certain data come naturally in the form of a table(as a table of rows and columns). Such data cannot be represented using 1D array, and would instead require a two-dimensional(2D) array. Two-dimensional array can be defined as an array of arrays. The 2D arrays are also known as matrix.</p>
<p>The syntax to declare the 2D array is given below.</p>
<pre><code>data_type array_name[num_rows][num_columns];  
</code></pre>
<p>For example:</p>
<pre><code>int matrix[5][4];  
</code></pre>
<p>Here 5 is the number of rows, and 4 is the number of columns.</p>
<p>The two-dimensional array can be initialized using either of following approaches:</p>
<pre><code>int matrix[4][3]={{1,2,3},{2,3,4},{3,4,5},{4,5,6}};  
</code></pre>
<p>or</p>
<pre><code>int matrix[4][3]={1,2,3,2,3,4,3,4,5,4,5,6};  
</code></pre>
<p>A matrix of 'M' rows and 'N' rows will have 'M * N' elements.</p>
<p>As explained in chapter &quot;Integer instructions&quot;, a 2D array 'a' with 4 rows and 3 columns as shown below:</p>
<p><img src="images/matrix.png" alt="Matrix" title="Matrix" /></p>
<p>would be represented in memory as:</p>
<p><img src="images/matrix_representation.png" alt="Matrix in memory" title="Matrix in memory" /></p>
<h2 id="pointers"><a class="header" href="#pointers">Pointers</a></h2>
<p>A related concept to arrays is pointers. In the desciption of arrays above we said that the name of the array <strong>points to the memory location of the start of the array</strong>. What that means is the array name (<em>scores</em>) hold the address of the memory location where the first element of the array is stored. We can define pointer variables of other types - <em>int, char, and float</em> - that hold the address of the memory location holding the data. </p>
<p>Memory in (most) computers is byte addressable. This means that every byte (8-bits) of memory in the machine has an address. When the programmer defines a variable in C, the compiler allocates the appropriate size required at a specific location in memory. So <code>int x;</code> in a program instructs the compiler to reserve 8-bytes somewhere in memory. It also informs the compiler that we will be referring to this memory location in our program using the name <em>x</em>. Note that the programmer does not have the ability to specify where in memory those 8-bytes should be stored. The compiler decides the actual address to allocate and will allocate 8 contiguous bytes of memory for the variable <em>x</em>.</p>
<p>In the C programming language pointers are used to refer to the memory location of variables. In the code below we define a <em>int</em> variable <em>x</em> and initialize it with a value. The second line declares <em>y</em> as a pointer of type <em>int</em>. This means that <em>y</em> is now a variable that is intended to hold the <strong>address</strong> of another variable. In the third line we assign the address of <em>x</em> to <em>y</em>. Note that <code>&amp;x</code> means &quot;address of x&quot;. The very last statement we use <code>*y</code> to access the contents of the memory address pointed to by <em>y</em>. Since y is an integer (8-bytes) this means we are telling the compiler to interpret the 8 bytes starting from the address contained in <em>y</em> as an integer and pass it to <code>uart_print_num</code>. </p>
<pre><code class="language-c">int x = 2; // integer
int *y;    // pointer to an integer
y = &amp;x;    // assign the address of x to the pointer y

uart_print_num(x);  // this will print 2
uart_print_num(y);  // this will print the address of x

// This will print the contents of the memory location pointed to by y. 
// That memory location is also known in this program as x.
uart_print_num(*y);  //this will print 2
</code></pre>
<p>It is improtant to note that a pointer is useful <strong>only when it points to a valid location in memory</strong>. For example if we had not assigned <code>y</code> to <code>&amp;x</code> then it will contain an arbitrary value (not always 0). This means that when we later dereference y by using <code>*y</code> we will be attempting to access memory contents that may or may not be part of our program. Just like accessing memory  beyond the array bounds, this can also lead to bugs (including serious security bugs) and crashes. It is up to the programmer to ensure that pointers in the program always point to valid and intended memory locations.</p>
<p>This may seem interesting (or complex) but <strong>how are pointers useful?</strong> One way they are useful is to allow functions to manipulate data rather than copy of a data. When we pass a parameter to a function, behind the scenes, a copy of the value is created and the function sees the copy.</p>
<pre><code class="language-c">void some_fn(int y) {
  y = y * 2;
}

void main() {
  int x = 5;
  some_fn(x);
  uart_print_num(x); // what will be printed?
}
</code></pre>
<p>In the example above we pass a <em>int</em> to the function <code>some_fn</code>. No this creates a copy of the contents of variable <em>x</em> and gives that copy to the function via the stack (we will see more about that shortly). Inside <code>some_fn</code> we are using a copy of <em>x</em>. Note that even if the function was defined as <code>void some_fn(int x)</code> the <em>x</em> parameter used inside the function and the one in <code>main</code> are different memory locations that jusy happen to have the same name. Changing the value of a parameter passed this way will not change the original. So any changes insde <code>some_fn</code> will not affect the value of <em>x</em> in <code>main</code>. The last statement in <code>main</code> will print 5.</p>
<p>However, if we rewrite the code so that <code>some_fn</code> is passed a <code>int *</code> instead of an integer then instead of a copy the address of <em>x</em> will be passed. Here is that code:</p>
<pre><code class="language-c">void some_fn(int *y) {
  *y = *y * 2;
}

void main() {
  int x = 5;
  some_fn(&amp;x);
  uart_print_num(x); // what will be printed?
}
</code></pre>
<p>Note that there are two changes from the earlier version. The signature of the function is now <code>some_fn(int *y)</code>. Also, when we call this function we are passing it the address of <em>x</em> using the syntax <code>&amp;x</code>. Inside the function we tell the compiler to multiply the contents of the <strong>integer</strong> at address <code>y</code> and multiply that by 2. The result is then stored in the memory addres pointed to by <code>y</code>. Since we are operating on the &quot;memory address of x&quot; (also known as y inside <code>some_fn</code>) the actual contents of the variable <code>x</code> will now be changed. The final print statement will print 10.</p>
<p>That was a whirlwind tour of arrays and pointers. Now that we know a little about them let us practice using them by doing a few programming exercises.</p>
<h2 id="find-maximum-number-in-an-array-integer-array"><a class="header" href="#find-maximum-number-in-an-array-integer-array">Find maximum number in an array (Integer array)</a></h2>
<p>The objective of this exercise is to find the maximum number in a given array of numbers.</p>
<p>File to be used for this exercise is : exercises/c_functions/find_max.c. This file provides following skeleton. You will have to add code in 'find_max' function to find the find the maximum number in the given array of numbers.</p>
<pre><code class="language-c">#define NUM_ELEMENTS 7
int integer_array[NUM_ELEMENTS] = {2, 5, 6, 1, 3, 7, 0};

int find_max(int integer_array[], int n)
{
    int i;

    // Initialize 'max_val' variable as first element of array
    int max_val = integer_array[0];

    // Add code to iterate through array elements and find the maximum value in 'integer_array' and store the result in 'max_val'

    // Your code starts here

    // Your code ends here

    // return the maxumim value 'max_val'
    return max_val;
}


void main()
{
    int result = 0;

    // Find the element with maximum value in array 'integer_array' and store the result in variable 'result'

    // Your function called here
    result = find_max(integer_array, 7);

    uart_print_num(result);
}

</code></pre>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make find_max.elf
RUN_COMMAND: make run
</code></pre>
<p><strong>Pseudo code</strong>:</p>
<ol>
<li>Initialize a variable (say max_val) with first element of array</li>
<li>Iterate through array elements using a loop</li>
<li>Compare every element of array with current maximum val in variable 'max_val'.</li>
<li>If the array element is greater than 'max_val', update variable 'max_val' with current array element</li>
<li>Return the maximum value 'max_val' (at the end of loop after iterating through all the elements of array)</li>
</ol>
<p>A sample implementation of the above pseudo code is available in find_max_solution.c file. </p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make find_max_solution.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="memcopy-pointersstring"><a class="header" href="#memcopy-pointersstring">Memcopy (Pointers/String)</a></h2>
<p>We have already done multiple exercises to copy data from one location to another in the assembly programming section. In this exerise the objective is to write a <em>memcopy</em> function in C that will copy the specified amount of data from one memory location to another.</p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make memcopy.elf
RUN_COMMAND: make run
</code></pre>
<p>You should write your code in the designated location in the file memcopy.c</p>
<pre><code class="language-c">#include &quot;uart.h&quot;

void memcopy(char *dest, char *src, int n)
{
   // Add code below to to copy the contents from source array 'src' to destination array 'dest'
   // Number of characters to be copied is provided in argument 'n'

   //Your code here
}

void main()
{
    char src_str[] = &quot;Hello&quot;;
    char dest_str[10] = &quot;Howdy&quot;;

    // Your code starts here

    memcopy(dest_str, src_str, 6);

    // Your code ends here

    uart_puts(src_str);
    uart_puts(dest_str);
}
</code></pre>
<p><strong>Pseudo code</strong>:</p>
<ol>
<li>Iterate through all the characters of source string 'src' using a for/while loop. The length of the string is provided in argument 'n'</li>
<li>Copy the current character from source string 'src' to destination string 'dest'</li>
</ol>
<p>A sample implementation of the above pseudo code is available in memcopy_solution.c file. </p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make memcopy_solution.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="find-substring-in-a-string-nested-loops-break-statement"><a class="header" href="#find-substring-in-a-string-nested-loops-break-statement">Find substring in a string (Nested loops, break statement)</a></h2>
<p>In this exercise, given two strings orig_str and str_to_find, the objective is to find if str_to_find is a substring of orig_str. If yes, return the 1, else return 0.</p>
<p>You should write your code in the designated location in the file find_substring.c</p>
<pre><code class="language-c">int find_substring(char *orig_str, char *str_to_find, int orig_str_len, int sub_str_len)
{
    // Add code below to find substring 'str_to_find' in 'orig_str'. The length of original string and substring are  provided in 'orig_str_len' and 'sub_str_len'

    // Your code starts here
    
    // Your code ends here
}

void main()
{
    char original_string[] = &quot;Hello World!&quot;;
    char string_to_find[10] = &quot;Wor&quot;;
    int found = 0; 

    // Your function gets called here
    found = find_substring(original_string, string_to_find, 12, 3);

    uart_puts(original_string);
    uart_puts(string_to_find);
    uart_print_num(found);
}


</code></pre>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make find_substring.elf
RUN_COMMAND: make run
</code></pre>
<p><strong>Pseudo code</strong>:</p>
<ol>
<li>Loop for every index in the given string 'orig_str'. End at (orig_str_len - sub_str_len) as there cannot be a substring match after that point</li>
<li>Add a nested loop to iterate through the provided substring 'str_to_find'. Its length is available in argument 'sub_str_len'</li>
<li>Check if the current character in substring 'str_to_find' matches with the corresponding character in original string 'orig_str'</li>
<li>Exit the inner nested loop if the check in Step 3 results in a mismatch</li>
<li>At the end of inner nested loop, check if the inner loop had completed iterating through all elements of substring before exiting the loop </li>
<li>If the check in step 5 results in true implying all the characters in substring matched, return '1' to imply success and exit the function</li>
<li>If the check in step 5 results in false, go back to outer loop started in step 1 to move to next character of 'orig_str'</li>
<li>If the outer loop started in step 1 ends (without check in Step 5 resulting in true), return '0' to imply that there is no match</li>
</ol>
<p>A sample implementation of the above pseudo code is available in find_substring_solution.c file. </p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make find_substring_solution.elf
RUN_COMMAND: make run
</code></pre>
<h2 id="matrix-addition-2-d-array"><a class="header" href="#matrix-addition-2-d-array">Matrix addition (2-D array)</a></h2>
<p>In this exercise, we will take two square matrices, 'A' and 'B' as input parameters and store the result in matrix 'C'. Two matrices can be added only if they have the same dimensions. The result will be a matrix of the same dimensions. To perform the addition, numbers in matching postions in the input matrices are added and the result is placed in the same position in the output matrix. </p>
<p>You should write your code in the designated location in the file matrix_addition.c</p>
<pre><code class="language-c">#define N 3

int A[N][N] = { {1, 2, 3},
                {4, 5, 6},
                {7, 8, 9},
              };

int B[N][N] = { {1, 1, 1},
                {2, 2, 2},
                {3, 3, 3},
              };

int C[N][N] = { {0, 0, 0},
                {0, 0, 0},
                {0, 0, 0},
              };


void matrix_add(int A[][N], int B[][N], int C[][N])
{
   // Add code below

   // Your code starts here

   // Your code ends here
}

void main()
{
    // Your function called here
    matrix_add(A, B, C)
}

</code></pre>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make matrix_addition.elf
RUN_COMMAND: make run
</code></pre>
<p><strong>Pseudo code</strong>:</p>
<ol>
<li>Start a loop for iterating through all the row of matrices 'A' and 'B'</li>
<li>Start a nested loop(within the loop started in step 1) to iterate through all the columns of matrices 'A' and 'B'</li>
<li>Add the corresponding elements from matrix 'A' with matrix 'B' and store the result in corresponding position in matrix 'C' (That is, sum of A[i][j] and B[i][j] into C[i][j])</li>
<li>At the end of loops started in step 1 and 2, the result of sum of matrix 'A' and 'B' will be available in matrix 'C'</li>
</ol>
<p>A sample implementation of the above pseudo code is available in matrix_addition_solution.c file. </p>
<p>To compile and run:</p>
<pre><code>COMPILE_COMMAND: make matrix_addition_solution.elf
RUN_COMMAND: make run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="from-c-programs-to-assembly-code"><a class="header" href="#from-c-programs-to-assembly-code">From C Programs to Assembly Code</a></h1>
<p>In the previous chapter we learnt the syntax of the C programming language and practiced writing a few programs in C. As mentioned earlier the CPU understands instructions that are part of its ISA. Programs may be written in assembly language and a special application called an <em>Assembler</em> converts assembly code into binary format that can be read and executed by the processor.</p>
<p>So how does code written in C get executed by the processor? The C code is translated into assembly and that resulting assembly is then converted into a binary file which is executed on the processor. This is done by a combination of three applications - compiler, assembler, and linker. </p>
<p>The <em>compiler</em> translates code from a high-level language, like C, to assembly. The <em>assembler</em> then converts the assembly code to a binary format. In this chapter we will see what assembly code is generated by the compiler for some common code fragments in C. We will also learn how to disassemble binary files back to assembly code. But first, lets start by understanding the tools used for compilation and disassembly.</p>
<h2 id="tools-to-compile-and-disassemble"><a class="header" href="#tools-to-compile-and-disassemble">Tools to compile and disassemble</a></h2>
<p>In the previous chapters, we were using an utility called <strong>make</strong> to compile our programs. In all the exercises, running <em>make</em> in the directory with the code would automatically call the compiler or assembler as required. This was useful because <em>make</em> is a short command and it saves us the trouble of repeatedly typing the longer command to invoke the compiler/assembler.</p>
<p>What is actually executed when we <em>make</em> is specified in a file named <strong>Makefile</strong>. When the <em>make</em> command is executed, it uses the contents in this file to determine which files to compile/assemble. There is also an additional advantage in using this utility. It uses the timestamp of files to determine when they were last updated and selectively compiles only those files that have changed since the last invocation of <em>make</em>. At every invocation of the <em>make</em>, only the files that were changed after previous compilation would be compiled. </p>
<h3 id="overview"><a class="header" href="#overview">Overview</a></h3>
<p>Let us first take a step back and see what is involved in compiling a C source code into an executable file. The figure below shows the process of converting a C program file to a binary file that can be executed by the QEMU simulator.</p>
<p><img src="images/compilation.png" alt="Compilation process" title="Compilation process" /></p>
<p>Large programs can have multiple code files and those files can be a combination of C (or other high-level languages) and assembly. First, the C file is processed by an application called the <em>compiler</em> which translates the C program to assembly. For this book we use a free and open-source compiler called GCC. The specific version that we use translates C programs to ARM assembly. The generated assembly is further translated by an assembler into a binary format called an <em>object file</em>. GCC does both translations and so we do not see the intermediate assembly file. It is possible to make the compiler stop after generating the assembly files. We will see how to do this later.</p>
<p>The object files could have references to functions in other object files. For example, in the programming exercises in previous chapters we used a function <code>uart_puts()</code> to print characters. However, this function is not present in the file where the function is called. Instead, we include  <em>uart.h</em> to tell the compiler that (1) a function named <code>uart_puts()</code> exists and (2) it maybe in a different file that also has to be compiled. The code for <code>uart_puts()</code> is in a <em>exercises/common/uart.c</em>.  Since the function is in a different file, the compiler does not know what program  address to branch to when calling that function.</p>
<p>So GCC, when generating the object file, leaves a label (i.e. a placeholder) for the target of the branch instruction. After creating all the object files - one for each program file - we use a <em>linker</em> to combine them together and create one final ELF executable file. 
The linker takes one or more object files and a <strong>linker configuration file</strong> and generates an ELF executable. In doing so, it also resolves references to external symbols (such as <em>uart_puts</em>) and assigns final addresses to functions and variables. The output of the linker is in <strong>ELF</strong> file format.</p>
<p>ELF stands for <strong>Executable and Linking Format</strong> and it is a file format used for  binary executables. This file is organized into <strong>sections</strong>. Each section can hold executable code, data, debugging data, symbol tables, relocation information etc.</p>
<p>On a computer that is running an operating system an ELF file will be sufficient to run the program. When we execute the ELF file on such a system, yet another application called the <em>loader</em> reads the sections in the ELF file and loads them into memory. The addresses at which to load each section is provided in the ELF file.</p>
<p>However, in this book we are running our code &quot;bare metal&quot;, meaning there is no operating system (and so no loader either!!) that can help with running our program.  Therefore, we need to convert the ELF executable to a simple plain binary file format that can be executed bare-metal by QEMU simulator. This is accomplished by the <strong>objcopy</strong> step in the above diagram. Finally, we have a file that the QEMU simulator can execute and produce an output.</p>
<h3 id="compiling-hello-world"><a class="header" href="#compiling-hello-world">Compiling Hello World</a></h3>
<p>We use <strong>ARM GNU Toolchain</strong>  which contains the GNU C/C++ Compiler (GCC), Assembler, Linker and various utilities (referred to as binutils). The compiler that we use to compile our C files is: <strong>aarch64-none-elf-gcc</strong>.
Let us now start with the Hello World  example that we used in the <strong>Programming in C</strong> section and understand how the above steps are performed. Here is the code:</p>
<pre><code class="language-c">#include &quot;uart.h&quot;
void main() {
  uart_puts(&quot;Hello World&quot;);
}
</code></pre>
<p>Readers can follow along by executing the commands specified in this section. The directory to work in is at:</p>
<pre><code>exercises/c_functions/hello_world_example.c
</code></pre>
<p>The first line of the above code starts with &quot;#include&quot; directive.  This directive tells the preprocessor (which is the first pass of the compiler) to insert the contents of another file into the source code at the point where the #include directive is found. Include directives are typically used to include the C header files for C functions that are held outside of the current source file. We use it in our program to make use of the <code>uart_puts()</code> function declared within <strong>uart.h</strong> file. The <strong>uart.h</strong> file is located at the <em>exercises/include/</em> directory. </p>
<p><strong>Step 1: Use this command to compile the above hello_world_example.c file:</strong></p>
<pre><code>aarch64-none-elf-gcc -ffreestanding -g -nostdinc -nostdlib -nostartfiles -I../include/ \
-c hello_world_example.c -o hello_world_example.o
</code></pre>
<p>To compile our code we use the compiler <strong>aarch64-none-elf-gcc</strong> followed by a series of options and a list of files to be compiled. </p>
<p><code>aarch64-none-elf-gcc &lt;list of options&gt; &lt;list of files&gt;</code> </p>
<p>Options are used to control the behavior of the compiler and all of them start with a hyphen followed by one or more alphanumeric characters. While aarch64-none-elf-gcc supports many of them, only few options will be needed by us. If you are curious to learn about all of the options you can run the command below to list them all: </p>
<p><code>aarch64-none-elf-gcc -v --help</code></p>
<p>The following table provides details and purpose of the options used by the above command line.</p>
<table><thead><tr><th>Compiler Option</th><th>Description</th></tr></thead><tbody>
<tr><td>-o &lt;file&gt;</td><td>Place the output in &lt;file&gt;. This will be the name and path of generated object files</td></tr>
<tr><td>-I &lt;dir&gt;</td><td>Add &lt;dir&gt; to the to list of directories to be searched for include files</td></tr>
<tr><td>-c</td><td>Compile and assemble the C file, but do not link</td></tr>
<tr><td>-ffreestanding</td><td>Indicate that the file should be compiled for a freestanding, not a hosted, environment. A freestanding environment is one in which the standard library may not exist, and program startup may not be at symbol &quot;main&quot;</td></tr>
<tr><td>-g</td><td>Generate debug information in generated object files</td></tr>
<tr><td>-nostdinc</td><td>Do not search the standard system directories or builtin directories for include files</td></tr>
<tr><td>-nostdlib</td><td>Do not link with standard C libraries</td></tr>
<tr><td>-nostartfiles</td><td>Do not use the standard system startup files when linking</td></tr>
</tbody></table>
<p>This command produces object file hello_world_example.o. The option <strong>-ffreestanding</strong> is used to specify that the code would be run directly on hardware and there is no underlying operating system support. 
As there is no operating system support, the application will have to be self-contained.  We need to provide all the suporting code ourselves and cannot rely on standard C libraries and include files. We use the options <strong>-nostdinc -nostdlib -nostartfiles</strong> to tell the compiler not to make use of any standard include files, libraries or start files.</p>
<p>The step above has created the <strong>object file</strong> hello_world.o. Now the GNU linker can be used to create the <strong>executable file</strong> from object files created by compiler. The GNU linker can be invoked using command <strong>aarch64-none-elf-ld</strong>. </p>
<p><strong>Step 2: Use this command to generate hello_world_example.elf file using the hello_world_example.o object file that we produced using step 1:</strong></p>
<p><code>aarch64-none-elf-ld -nostdlib -nostartfiles -T link.ld -o hello_world_example.elf start.o hello_world_example.o ../common/uart.o</code></p>
<p>The usage syntax of <strong>aarch64-none-elf-ld</strong> is similar to <strong>aarch64-none-elf-gcc</strong>.</p>
<p><code>aarch64-none-elf-ld &lt;list of options&gt; &lt;list of object files&gt; </code></p>
<p>The <strong>-nostdlib -nostartfiles</strong> options tell the linker not to link with standard C library or use standard start files while producing the executable. A linker script <strong>link.ld</strong> is passed to exercise greater control over the linking process. As you can notice in the above command, we use two more object files <strong>start.o</strong> and <strong>uart.o</strong> in the above command to produce the final executable. File <strong>start.o</strong> contains the code to boot the CPU and hand over the control to <strong>main</strong> function. The boot process involved initialization and configuration of various system registers, general purpose registers and memory. We will explain more about the boot process in a Part-2 of this book.</p>
<p>We run the generated executable using a free and open-source emulator named <a href="https://www.qemu.org/download">QEMU</a>. It can emulate a set of different hardware and device models. As QEMU requires the file to be executed in binary file format, we convert the ELF file to binary file using <strong>aarch64-none-elf-objcopy</strong> utility by running following command: </p>
<p><strong>Step 3: Use this command to convert the ELF file to binary file:</strong></p>
<p><code>aarch64-none-elf-objcopy -O binary hello_world_example.elf kernel8.img</code></p>
<p>The above command will produce a binary image named kernel.img. </p>
<p><strong>Step 4: Use this command to run kernel.img file using QEMU:</strong></p>
<p><code>qemu-system-aarch64 -M raspi3 -kernel kernel8.img -serial null -serial stdio -nographic</code></p>
<h3 id="disassembly"><a class="header" href="#disassembly">Disassembly</a></h3>
<p>Disassembly is the process of converting a binary file - typically an ELF file - back to assembly. Let us now see how we can translate the ELF executable back into assembly format using an utility called disassembler. <strong>aarch64-none-elf-objdump</strong> utility provided as part of <em>binutils</em> in the GNU toolchain can be used to disassemble the object file or ELF executable.</p>
<p><strong>Step 5: Use this command to disassemble the object file:</strong></p>
<pre><code>aarch64-none-elf-objdump -D hello_world_example.o &gt; hello_world_example.disass
</code></pre>
<p>The -D option is used here to specify that all the code and data sections from hello_world_example.o should be disassembled.</p>
<p>Disassembly will produce output for multiple sections. We will look at it section by section.</p>
<p><strong>Disassembly of the code section:</strong></p>
<p>The .text section contains the instruction opcodes produced by the compiler for the C function. The disassembly output produced for the .text(code) section by the above command is shown below:</p>
<pre><code>hello_world_example.o:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000000000 &lt;main&gt;:
   0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   4:	910003fd 	mov	x29, sp
   8:	90000000 	adrp	x0, 0 &lt;main&gt;
   c:	91000000 	add	x0, x0, #0x0
  10:	94000000 	bl	0 &lt;uart_puts&gt;
  14:	d503201f 	nop
  18:	a8c17bfd 	ldp	x29, x30, [sp], #16
  1c:	d65f03c0 	ret
</code></pre>
<p>The first column in the disassembly output displays the address of each opcode in the section. The second column displays the machine code for the instruction. The third column displays the assembly instruction. As an example, let us consider this line:</p>
<pre><code>   c:	91000000 	add	x0, x0, #0x0
</code></pre>
<p>Here, the assembly instruction is <strong>add	x0, x0, #0x0</strong>. It machine code is: <strong>0x91000000</strong>. The address where this machine code would be placed  in memory is 0xc. However, this is a temporary address provided just for the object file. The final address will be decided later when all object files are merged together into an <em>elf</em> executable. Note that the address of each instruction is 4 bytes after the previous one. This is because each instruction is 4 bytes long. </p>
<p>In our <em>hello_world_example.c</em> we have a function with the name main. The text <em>&lt;main&gt;</em> in the code section indicates that this is the disassembly of the function named <em>main</em>. To the left of the function name is a long chain of 0s. This is meant to be the address of the function - i.e. the location that this function will be placed in memory. However, the final address of code (and therefore functions) and data is determined when we link all the object files into an <em>elf</em> file. In the object file we have only example addresses that always start at 0x0 (for both code and data sections).</p>
<p>The first instruction <code>stp	x29, x30, [sp, #-16]!</code> stores a pair of registers x29 and x30 into the stack. The next instruction copies the stack pointer to x29. Why does that need to be done? From the earlier assembly program examples we know that functions have to save values of the registers that they plan to overwrite. Because any previous function that called the current one may be storing data in those registers and we do not want to <em>clobber</em> the values. For small assembly programs that are written by one programmer we can make up ad-hoc rules on what registers are to be saved. But in the real world, code written one programmer is reused by others. It is quite common for a programmer to write library code that will be distributed as binary files and other programmers will call functions in this library from their own code. </p>
<p>The ARM architecture has an associated document called the ARM Procedure Call Standard (PCS). It defines, among other things, who should save register values - the calling function (caller) or the called function (callee). As per the PCS registers X29 (frame pointer) and X30 (link register) are special registers that must be saved by the callee. Any function that intends to call another must save X30. </p>
<p>Function <em>main</em> will overwrite both X29 and X30. As can be seen from the disassembly-</p>
<ul>
<li>The second instruction copies the stack pointer (SP) into X29.</li>
<li>We make a call to <em>uart_puts</em> function - this is done using the <code>bl</code> isntruction. That call will overwrite X30.</li>
</ul>
<p>Since X29 and X30 are going to be overwritten in <em>main</em> the compiler saves them on the stack and restores them at the end of the function. Note that the register X29 in AArch64 is used as a <em>frame pointer</em>. For now it is not necessary to know more about the FP so we will save that explanation for later.</p>
<p><strong>Disassembly of the data section:</strong></p>
<p>The .rodata section contains the Read-only data produced by the compiler for the <strong>Hello World</strong> string referred by the C function. The disassembly output produced for the .rodata section is shown below:</p>
<pre><code>Disassembly of section .rodata:

0000000000000000 &lt;.rodata&gt;:
   0:	6c6c6548 	ldnp	d8, d25, [x10, #-320]
   4:	6f57206f 	umlal2	v15.4s, v3.8h, v7.h[1]
   8:	00646c72 	.inst	0x00646c72 ; undefined
</code></pre>
<p>The data section also looks like the code section. Though there is no code in this section of the file,  the disassembler still disassembles it as though it is code. However, be assured that this section will not get executed. We can ignore the last column with instruction mnemonics. What is of interest is the second column. The second column is the data that will be stored in memory. Each line in this column shows 4 bytes of data. Also, that byte is printed in <strong>reverse order</strong>. So to get the correct data one has to read the second column from right to left. For example, 6c6c6548 in the disassembly above, should be interpreted in following order: 48, 65, 6c, 6c. In general, disassembly of any data section will have to be interpreted in the reverse order.</p>
<p>The string <strong>Hello World</strong> that we used in our program is stored in the data section.
The column below shows the data values and the corresponding ASCII character of that data value.</p>
<table><thead><tr><th>ASCII Value</th><th>Character</th></tr></thead><tbody>
<tr><td>48</td><td>H</td></tr>
<tr><td>65</td><td>e</td></tr>
<tr><td>6c</td><td>l</td></tr>
<tr><td>6c</td><td>l</td></tr>
<tr><td>6f</td><td>o</td></tr>
<tr><td>20</td><td>space</td></tr>
<tr><td>57</td><td>W</td></tr>
<tr><td>6f</td><td>o</td></tr>
<tr><td>72</td><td>r</td></tr>
<tr><td>6c</td><td>l</td></tr>
<tr><td>64</td><td>d</td></tr>
<tr><td>00</td><td>null</td></tr>
</tbody></table>
<p>The first four bytes of this string are 48 65 6c 6c. When reversed it becomes 6c 6c 65 48. This corresponds to the first four bytes of the .data section disassembly. </p>
<p><strong>Disassembling the elf file:</strong></p>
<p>We can also choose to disassemble the ELF executable instead of the object file. This would produce the disassembly of startup file(start.o) and library file(uart.o) as well. As this disassembly output would be very long, small snippets of disassembly from various sections are shown below. The main point of interest here is that now all the memory addresses are finally set to the values they will be loaded at when the program executes.</p>
<pre><code>hello_world_example.elf:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000080000 &lt;_start&gt;:
   80000:       d53800a1        mrs     x1, mpidr_el1
   80004:       92400421        and     x1, x1, #0x3
   80008:       b4000061        cbz     x1, 80014 &lt;_start+0x14&gt;
   8000c:       d503205f        wfe
   80010:       17ffffff        b       8000c &lt;_start+0xc&gt;
   80014:       580001a1        ldr     x1, 80048 &lt;_start+0x48&gt;
   80018:       9100003f        mov     sp, x1
   8001c:       580001a1        ldr     x1, 80050 &lt;_start+0x50&gt;
   80020:       18000102        ldr     w2, 80040 &lt;_start+0x40&gt;
   80024:       340000a2        cbz     w2, 80038 &lt;_start+0x38&gt;
   80028:       f800843f        str     xzr, [x1], #8
   8002c:       51000442        sub     w2, w2, #0x1
   80030:       35ffffa2        cbnz    w2, 80024 &lt;_start+0x24&gt;
   80034:       94000013        bl      80080 &lt;uart_init&gt;
   80038:       94000008        bl      80058 &lt;main&gt;
   8003c:       17fffff4        b       8000c &lt;_start+0xc&gt;
        ...


0000000000080058 &lt;main&gt;:
   80058:       a9bf7bfd        stp     x29, x30, [sp, #-16]!
   8005c:       910003fd        mov     x29, sp
   80060:       90000000        adrp    x0, 80000 &lt;_start&gt;
   80064:       9114c000        add     x0, x0, #0x530
   80068:       94000057        bl      801c4 &lt;uart_puts&gt;
   8006c:       d503201f        nop
   80070:       a8c17bfd        ldp     x29, x30, [sp], #16
   80074:       d65f03c0        ret
        ...



0000000000080080 &lt;uart_init&gt;:
   80080:       d28a0081        mov     x1, #0x5004                     // #20484
   80084:       d28a0c07        mov     x7, #0x5060                     // #20576
   80088:       f2a7e421        movk    x1, #0x3f21, lsl #16
   8008c:       f2a7e427        movk    x7, #0x3f21, lsl #16
   80090:       d28a0984        mov     x4, #0x504c                     // #20556
   80094:       d28a0a05        mov     x5, #0x5050                     // #20560
   80098:       b9400020        ldr     w0, [x1]
   8009c:       f2a7e424        movk    x4, #0x3f21, lsl #16
   800a0:       f2a7e425        movk    x5, #0x3f21, lsl #16
        ...

00000000000801c4 &lt;uart_puts&gt;:
   801c4:   39400001    ldrb    w1, [x0]
   801c8:   34000201    cbz w1, 80208 &lt;uart_puts+0x44&gt;
   801cc:   d28a0a82    mov x2, #0x5054                 // #20564
   801d0:   d28a0804    mov x4, #0x5040                 // #20544
   801d4:   f2a7e422    movk    x2, #0x3f21, lsl #16
   801d8:   f2a7e424    movk    x4, #0x3f21, lsl #16
        ...

Disassembly of section .rodata:

0000000000080530 &lt;.rodata&gt;:
   80530:       6c6c6548        ldnp    d8, d25, [x10, #-320]
   80534:       6f57206f        umlal2  v15.4s, v3.8h, v7.h[1]
   80538:       00646c72        .inst   0x00646c72 ; undefined
        ...
</code></pre>
<h2 id="what-we-learned-4"><a class="header" href="#what-we-learned-4">What we learned</a></h2>
<ul>
<li>How C and assembly programs are compiled to ELF files</li>
<li>The ELF file is concerted to a binary file that can be used to run bare-metal</li>
<li>How to disassemble an ELF or object file </li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="disassembly-examples"><a class="header" href="#disassembly-examples">Disassembly examples</a></h1>
<p>In this chapter we will examine the disassembly of some common C language syntax.</p>
<h2 id="disassembly-of-control-flow-syntax"><a class="header" href="#disassembly-of-control-flow-syntax">Disassembly of control-flow syntax</a></h2>
<p>Let us now look at disassembly of examples we had introduced in the <strong>Control flow</strong> subsection from <strong>C Language Syntax</strong>.</p>
<h3 id="if-else-1"><a class="header" href="#if-else-1">If-Else</a></h3>
<p>Here is the code for <em>if-else</em> statement example from C language syntax section: </p>
<pre><code class="language-c">#include &quot;uart.h&quot;


int main()
{
    int lower_int_val = find_lower_int(2, 6);
    uart_print_num(lower_int_val);
}

// function returns the lower of two integers
int find_lower_int(int x, int y) {
  if (x &lt;= y) {
    // if the value of x is less than or equal to y
    // execute the code in this block
    return x;
  } else {
    // if the condition above is false
    // execute code in this block
    return y;
  }
}

</code></pre>
<p>Path of example:</p>
<pre><code>exercises/c_functions/if_else_example.c
</code></pre>
<p>The command for compiling if_else_example.c file is:</p>
<pre><code>aarch64-none-elf-gcc -O0 -ffreestanding -nostdinc -nostdlib -nostartfiles -I../include/ \
-c if_else_example.c -o if_else_example.o
</code></pre>
<p>The <strong>-O0</strong> option in the above command tells compiler not to optimize the code. The compiler optimization tries to improve the generated assembly code by making it consume fewer resources (compile time, memory space etc) so that it will result in faster-running machine code. We disable optimization here to make it easier to relate the C statements with the disassembly. Compiler supports different levels for optimization from <strong>-O0</strong> to <strong>-O3</strong>. <strong>-O0</strong> completly disables optimization and <strong>-O3</strong> performs maximum amount of optimization.</p>
<p>The linker command to produce final executable for this example is:</p>
<pre><code>aarch64-none-elf-ld -nostdlib -nostartfiles start.o if_else_example.o ../common/uart.o -T link.ld -o if_else_example.elf
</code></pre>
<p>For generating disassembly for examples in this chapter we will an add option <strong>--source</strong> to <strong>objdump</strong> command. Turning on this switch tells it to interleave source code with disassembly. This would help in associating C lines with assembly. Here is the full command to produce the disassembly output for this example:</p>
<pre><code>aarch64-none-elf-objdump --source -d if_else_example.o &gt; if_else_example.disass
</code></pre>
<p>Let us now look at the output in more detail in small logical blocks. We will start with the <em>main</em> function. </p>
<p>First registers x29 and x30 iare stored on the stack and SP is moved to x29.</p>
<pre><code>0000000000080088 &lt;main&gt;:

int main()
{
   80088:       a9be7bfd        stp     x29, x30, [sp, #-32]!
   8008c:       910003fd        mov     x29, sp
</code></pre>
<p>Then arguments are prepared for calling the function <strong>find_lower_int</strong>. Before calling the function, values 2 and 6 are moved to registers <strong>w0</strong> and <strong>w1</strong>. If you recall from <strong>Chapter 9: Functions</strong>, registers <strong>w0</strong> through <strong>w7</strong> are used to pass arguments to functions and <strong>w0</strong> is used to return a value from the function. </p>
<pre><code>    int lower_int_val = find_lower_int(2, 6);
   80090:       528000c1        mov     w1, #0x6                        // #6
   80094:       52800040        mov     w0, #0x2                        // #2
</code></pre>
<p>The function <strong>find_lower_int</strong> is called using <strong>bl</strong> instruction. Finally the return value from the function which is placed in GPR <strong>x0</strong> is stored to stack at offset 0x28.</p>
<pre><code>   80098:       97fffff0        bl      80058 &lt;find_lower_int&gt;
   8009c:       b9001fe0        str     w0, [sp, #28]
</code></pre>
<p>This code loads back the value from stack to GPR <strong>x0</strong> and calls the <strong>uart_print_num</strong> function to print the value in UART.</p>
<pre><code>    uart_print_num(lower_int_val);
   800a0:       b9801fe0        ldrsw   x0, [sp, #28]
   800a4:       940000db        bl      80410 &lt;uart_print_num&gt;
}
</code></pre>
<p>The above code loads back the value from stack to GPR <strong>x0</strong> and calls the <strong>uart_print_num</strong> function to print the value in UART.</p>
<pre><code>   800a8:       d503201f        nop
   800ac:       a8c27bfd        ldp     x29, x30, [sp], #32
   800b0:       d65f03c0        ret
</code></pre>
<p>Now let us us now look at the function <strong>find_lower_int</strong> that returns the lower of two integers. The <strong>sub</strong> instruction creates space for stack and following <strong>str</strong> instructions save <strong>w0</strong> and <strong>w1</strong> in stack at offset #12 and #8.</p>
<pre><code>// function returns 
int find_lower_int(int x, int y) {
   80058:       d10043ff        sub     sp, sp, #0x10
   8005c:       b9000fe0        str     w0, [sp, #12]
   80060:       b9000be1        str     w1, [sp, #8]
</code></pre>
<p>This code loads back <strong>w1</strong> and <strong>w0</strong> from stack from offsets <strong>12</strong> and #8, effectively swapping the original value of <strong>w0</strong> with <strong>w1</strong>. It then compares the value of <strong>w1</strong> with <strong>w0</strong> and branches to location 0x8007c if value in <strong>w1</strong> is greater than <strong>w0</strong> value.</p>
<pre><code>  if (x &lt;= y) {
   80064:       b9400fe1        ldr     w1, [sp, #12]
   80068:       b9400be0        ldr     w0, [sp, #8]
   8006c:       6b00003f        cmp     w1, w0
   80070:       5400006c        b.gt    8007c &lt;find_lower_int+0x24&gt;
</code></pre>
<p>This stores the value in <strong>w0</strong> to stack at offset #12. It then unconditionally branches to location 0x80080.</p>
<pre><code>    // if the value of x is less than or equal to y
    // execute the code in this block
    return x;
   80074:       b9400fe0        ldr     w0, [sp, #12]
   80078:       14000002        b       80080 &lt;find_lower_int+0x28&gt;
</code></pre>
<p>This loads register <strong>w0</strong> from stack at offset #8.</p>
<pre><code>  } else {
    // if the condition above is false
    // execute code in this block
    return y;
   8007c:       b9400be0        ldr     w0, [sp, #8]
  }
}
</code></pre>
<p>It finally adjusts the stack by 0x10 to remove the space it had allocated for itself at the start of the function.</p>
<pre><code>   80080:       910043ff        add     sp, sp, #0x10
   80084:       d65f03c0        ret
</code></pre>
<p>You would have noticed, with <strong>-O0</strong> option that we had used to <strong>disable optimizations</strong> makes the generated code very verbose. It forces the generated assembly code to make use of many unnecessary stack operations to save and restore intermediate results. At the same time, using a higher optimization level like <strong>-O3</strong> would make it hard to relate the C statements with generated disassembly. For example, here is the if-else example from above compiled with <strong>-O1</strong>.</p>
<p>Use the command line below to to compile:</p>
<pre><code>aarch64-none-elf-gcc -O1 -ffreestanding -nostdinc -nostdlib -nostartfiles -I../include/ \
-c if_else_example.c -o if_else_example.o
</code></pre>
<p>Let us first look at the disassembly output of the <strong>main</strong> function:</p>
<pre><code>0000000000000000 &lt;main&gt;:

int main()
{
   0:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!

    int lower_int_val = find_lower_int(2, 6);
    uart_print_num(lower_int_val);
   4:	d2800040 	mov	x0, #0x2                   	// #2
   8:	910003fd 	mov	x29, sp
    uart_print_num(lower_int_val);
   c:	94000000 	bl	0 &lt;uart_print_num&gt;
  10:	a8c17bfd 	ldp	x29, x30, [sp], #16
  14:	d65f03c0 	ret
</code></pre>
<p>Compilers are capable of performing fairly advanced optimizations. 
Here, the compiler appears to have intelligently figured out that <strong>0x2</strong> is lower that <strong>0x6</strong> and moves value <strong>0x2</strong> to register <strong>x0</strong>, thereby completely avoiding the need to perform call to <strong>find_lower_int</strong> function!! It was able to do this because we passed 2 and 6 as literal values. So the compiler figured out that in this instance the output of <code>find_lower_int()</code> will always be 2.</p>
<p>Let us now see the code for <strong>find_lower_int</strong> function:</p>
<pre><code>0000000000000000 &lt;find_lower_int&gt;:
  } else {
    // if the condition above is false
    // execute code in this block
    return y;
  }
}
   0:	6b01001f 	cmp	w0, w1
   4:	1a81d000 	csel	w0, w0, w1, le
   8:	d65f03c0 	ret
</code></pre>
<p>Although, the <strong>main</strong> function completely avoided call to <strong>find_lower_int</strong> function, the compiler has still generates code for the <strong>find_lower_int</strong> function so that it can honour calls from any other function that could not be optimized. It chooses to perform the entire functionality by using the <strong>csel</strong> instruction and returns the result in <strong>x0</strong> to its caller.</p>
<p>As an exercise, you can try generating just the disassenbly output without interleaving source code for this example.</p>
<p>At <strong>-O0</strong> the compiler generates very verbose code with a lot of unnecessary loads and stores. At higher optimization levels it could completely remove C code. This is a good thing in the real world but not useful when we want to show readers examples of what C code looks like when compiled. Therefore, for the remaining examples, we will use an optimization level that helps illustrate the point we want to convey.</p>
<h3 id="switch-statement-example"><a class="header" href="#switch-statement-example">Switch statement example</a></h3>
<p>Let us now look at the <strong>switch</strong> statement from the C language syntax section: </p>
<pre><code class="language-c">#include &quot;uart.h&quot;
int SAMPLE_VALUE = 25;

void main() {
  int x = SAMPLE_VALUE;

  switch (x) {
    case 5:
      uart_puts(&quot;X is 5&quot;);
      break;
    case 10:
    case 15:
      uart_puts(&quot;X is 10 or 15&quot;);
      break;
    case 25:
      uart_puts(&quot;X is 25&quot;);
      break;
    default:
      uart_puts(&quot;I dont know what X is...&quot;);
      break;
  }
}
</code></pre>
<p>Path of example:</p>
<pre><code>exercises/c_functions/switch_example.c
</code></pre>
<p>Compiler/Linker commands:</p>
<pre><code>aarch64-none-elf-gcc -O1 -g -ffreestanding -nostdinc -nostdlib -nostartfiles -I../include/ \
-c switch_example.c -o switch_example.o
aarch64-none-elf-ld -nostdlib -nostartfiles start.o switch_example.o ../common/uart.o \
-T link.ld -o switch_example.elf
</code></pre>
<p>Disassembly command:</p>
<pre><code>aarch64-none-elf-objdump --source -d switch_example.elf &gt; switch_example.disass
</code></pre>
<p>Disassembly output:</p>
<pre><code>#include &quot;uart.h&quot;
int SAMPLE_VALUE = 25;

void main() {
   80058:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
   8005c:	910003fd 	mov	x29, sp
  int x = SAMPLE_VALUE;
   80060:	90000000 	adrp	x0, 80000 &lt;_start&gt;
   80064:	b945bc00 	ldr	w0, [x0, #1468]

  switch (x) {
   80068:	71003c1f 	cmp	w0, #0xf
   8006c:	540000c0 	b.eq	80084 &lt;main+0x2c&gt;  // b.none
   80070:	5400012c 	b.gt	80094 &lt;main+0x3c&gt;
   80074:	7100141f 	cmp	w0, #0x5
   80078:	540001a0 	b.eq	800ac &lt;main+0x54&gt;  // b.none
   8007c:	7100281f 	cmp	w0, #0xa
   80080:	54000201 	b.ne	800c0 &lt;main+0x68&gt;  // b.any
    case 5:
      uart_puts(&quot;X is 5&quot;);
      break;
    case 10:
    case 15:
      uart_puts(&quot;X is 10 or 15&quot;);
   80084:	90000000 	adrp	x0, 80000 &lt;_start&gt;
   80088:	91162000 	add	x0, x0, #0x588
   8008c:	94000062 	bl	80214 &lt;uart_puts&gt;
      break;
   80090:	1400000a 	b	800b8 &lt;main+0x60&gt;
  switch (x) {
   80094:	7100641f 	cmp	w0, #0x19
   80098:	54000141 	b.ne	800c0 &lt;main+0x68&gt;  // b.any
    case 25:
      uart_puts(&quot;X is 25&quot;);
   8009c:	90000000 	adrp	x0, 80000 &lt;_start&gt;
   800a0:	91166000 	add	x0, x0, #0x598
   800a4:	9400005c 	bl	80214 &lt;uart_puts&gt;
      break;
   800a8:	14000004 	b	800b8 &lt;main+0x60&gt;
      uart_puts(&quot;X is 5&quot;);
   800ac:	90000000 	adrp	x0, 80000 &lt;_start&gt;
   800b0:	91160000 	add	x0, x0, #0x580
   800b4:	94000058 	bl	80214 &lt;uart_puts&gt;
      break;
   800b8:	a8c17bfd 	ldp	x29, x30, [sp], #16
   800bc:	d65f03c0 	ret
    default:
      uart_puts(&quot;I dont know what X is...&quot;);
      break;
   800c0:	90000000 	adrp	x0, 80000 &lt;_start&gt;
   800c4:	91168000 	add	x0, x0, #0x5a0
   800c8:	94000053 	bl	80214 &lt;uart_puts&gt;
}
   800cc:	17fffffb 	b	800b8 &lt;main+0x60&gt;

</code></pre>
<p>Let us now look at the output in more detail on how the compiler has transformed the switch and case statements: </p>
<p>It has converted the <strong>switch</strong> statement to a series of <strong>compare</strong> and <strong>conditional branch</strong> instructions. It compares the input argument against the values used in <strong>case</strong> statement and branches to the appropriate section of code generated for the corresponding <strong>case</strong> statement as shown below:</p>
<pre><code>  switch (x) {
   80068:	71003c1f 	cmp	w0, #0xf
   8006c:	540000c0 	b.eq	80084 &lt;main+0x2c&gt;  // b.none
   80070:	5400012c 	b.gt	80094 &lt;main+0x3c&gt;
   80074:	7100141f 	cmp	w0, #0x5
   80078:	540001a0 	b.eq	800ac &lt;main+0x54&gt;  // b.none
   8007c:	7100281f 	cmp	w0, #0xa
   80080:	54000201 	b.ne	800c0 &lt;main+0x68&gt;  // b.any
</code></pre>
<p>The code for each <strong>case</strong> statement gets the address of string literal to be printed using <strong>adrp</strong> instruction and performs a call to <strong>uart_puts</strong> function to print the string:</p>
<pre><code>      uart_puts(&quot;X is 5&quot;);
   800ac:	90000000 	adrp	x0, 80000 &lt;_start&gt;
   800b0:	91160000 	add	x0, x0, #0x580
   800b4:	94000058 	bl	80214 &lt;uart_puts&gt;
</code></pre>
<p>The code for <strong>default</strong> statement too similarly loads the corresponding string:</p>
<pre><code>    default:
      uart_puts(&quot;I dont know what X is...&quot;);
      break;
   800c0:	90000000 	adrp	x0, 80000 &lt;_start&gt;
   800c4:	91168000 	add	x0, x0, #0x5a0
   800c8:	94000053 	bl	80214 &lt;uart_puts&gt;
</code></pre>
<h3 id="for-loop"><a class="header" href="#for-loop">For Loop</a></h3>
<p>Let us now look at the <strong>For loop</strong> example from the C language syntax section: </p>
<pre><code class="language-c">#include &quot;uart.h&quot;
int NUM = 5;
void main() {
  int i;
  for(i = 0; i &lt; NUM; i++) {
    uart_puts(&quot;Value of i: &quot;);
    uart_print_num(i);
  }
}
</code></pre>
<p>Path of example:</p>
<pre><code>exercises/c_functions/for_loop_example.c
</code></pre>
<p>Compiler/Linker commands:</p>
<pre><code>aarch64-none-elf-gcc -O1 -ffreestanding -nostdinc -nostdlib -nostartfiles -I../include/ \
-c for_loop_example.c -o for_loop_example.o
aarch64-none-elf-ld -nostdlib -nostartfiles start.o for_loop_example.o ../common/uart.o -T link.ld -o for_loop_example.elf
</code></pre>
<p>Disassembly command:</p>
<pre><code>aarch64-none-elf-objdump --source -d for_loop_example.o &gt; for_loop_example.disass
</code></pre>
<p>Disassembly output:</p>
<pre><code>void main() {
   80068:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
   8006c:	910003fd 	mov	x29, sp
   80070:	a90153f3 	stp	x19, x20, [sp, #16]
   80074:	f90013f5 	str	x21, [sp, #32]
  for(i = 0; i &lt; NUM; i++) {
   80078:	d2800013 	mov	x19, #0x0                   	// #0
    uart_puts(&quot;Value of i: &quot;);
   8007c:	90000015 	adrp	x21, 80000 &lt;_start&gt;
   80080:	9115c2b5 	add	x21, x21, #0x570
  for(i = 0; i &lt; NUM; i++) {
   80084:	90000014 	adrp	x20, 80000 &lt;_start&gt;
   80088:	91160294 	add	x20, x20, #0x580
    uart_puts(&quot;Value of i: &quot;);
   8008c:	aa1503e0 	mov	x0, x21
   80090:	9400005d 	bl	80204 &lt;uart_puts&gt;
    uart_print_num(i);
   80094:	aa1303e0 	mov	x0, x19
   80098:	940000de 	bl	80410 &lt;uart_print_num&gt;
  for(i = 0; i &lt; NUM; i++) {
   8009c:	91000673 	add	x19, x19, #0x1
   800a0:	b9400280 	ldr	w0, [x20]
   800a4:	6b13001f 	cmp	w0, w19
   800a8:	54ffff2c 	b.gt	8008c &lt;main+0x34&gt;
  }
}
   800ac:	a94153f3 	ldp	x19, x20, [sp, #16]
   800b0:	f94013f5 	ldr	x21, [sp, #32]
   800b4:	a8c37bfd 	ldp	x29, x30, [sp], #48
   800b8:	d65f03c0 	ret
</code></pre>
<p>Let us now look at the output in more detail on how the <strong>for</strong> loop gets converted to assembly instructions: </p>
<p>As we recall from <strong>for</strong> loop section of C language syntax, the for loop syntax has three expressions: expr1 is the initial expression that is executed just once. The expression expr2 is a loop termination condition and is executed at the beginning of every iteration of the loop. The final expr3 typically changes variables that count the current iteration of the loop. The below code to move 0 to <strong>x19</strong> corresponds to initial expression that initializes i with 0:</p>
<pre><code>  for(i = 0; i &lt; NUM; i++) {
   80078:	d2800013 	mov	x19, #0x0                   	// #0
</code></pre>
<p>It subsequently initializes <strong>x21</strong> with address of string used in uart_puts within loop so that it need not repeat executing <strong>adrp</strong> instruction every iteration of the for loop: </p>
<pre><code>    uart_puts(&quot;Value of i: &quot;);
   8007c:	90000015 	adrp	x21, 80000 &lt;_start&gt;
   80080:	9115c2b5 	add	x21, x21, #0x570
</code></pre>
<p>It similarly initializes <strong>x20</strong> with the address of global variable <strong>NUM</strong>: </p>
<pre><code>   80084:	90000014 	adrp	x20, 80000 &lt;_start&gt;
   80088:	91160294 	add	x20, x20, #0x580
</code></pre>
<p>The following assembly instructions correspond to <strong>expr2</strong> and <strong>expr3</strong> of the for loop. The <strong>x19</strong> value is incremented by 1 by the <strong>add</strong> instruction. The <strong>ldr</strong> instruction loads the value in global variable <strong>NUM</strong> using the <strong>x20</strong> register it had initialized before the loop and compares the value with <strong>x19</strong>. The result of the compare is used to decide whether to jump back to the start of the loop(address 0x8008c) and exit the loop by not taking the branch (<strong>b.gt</strong>). 
for(i = 0; i &lt; NUM; i++) {
8009c:	91000673 	add	x19, x19, #0x1
800a0:	b9400280 	ldr	w0, [x20]
800a4:	6b13001f 	cmp	w0, w19
800a8:	54ffff2c 	b.gt	8008c &lt;main+0x34&gt;</p>
<p>It is left as an exercise to the reader to generate disassebly for the <strong>while</strong> and <strong>do-while</strong> loop examples in C Language Syntax section and analyze the disassembly output.</p>
<h2 id="disassembly-of-functions"><a class="header" href="#disassembly-of-functions">Disassembly of functions</a></h2>
<p>Let us now at disassembly output of some functions.</p>
<h3 id="swap-function-with-pointers"><a class="header" href="#swap-function-with-pointers">Swap function with pointers</a></h3>
<p>Let us now look at an example to swap two integer variables. The <strong>swap</strong> function in the code below swaps the integer variables <em>num1</em> and <em>num2</em> using a temporary variable <em>temp</em>. The temp variable is first assigned the value of the <em>num1</em> variable. Then, the value of the <em>num2</em> is assigned to <em>num1</em>. Finally, the temp (which holds the initial value of <em>num1</em>) is assigned to <em>num2</em> completing the swapping of the two variables. This is clearly a naive implementation that will not correctly swap the values. Why is that the case? When we call the <code>swap()</code> from <code>main()</code> by passing values NUM1 and NUM2 a copy of those values are passed as <em>num1</em> and <em>num2</em>. The scope of these copies is limited to the <code>swap()</code> function and those memory locations do not &quot;exist&quot; outside that function.</p>
<p>Let us take a look at the code for <strong>broken swap function</strong>: </p>
<pre><code>#include &quot;uart.h&quot;

// function to swap the two numbers
void swap(int num1,int num2)
{
    int temp;
    temp   = num1;
    num1   = num2;
    num2   =  temp;
}

int main()
{
    int NUM1 =  2, NUM2 = 5;

    //displaying numbers after swapping
    uart_print_num(NUM1);
    uart_print_num(NUM2);

    // Your code starts here

    swap(NUM1,NUM2);

    // Your code ends here

    //displaying numbers after swapping
    uart_print_num(NUM1);
    uart_print_num(NUM2);

    return 0;
}

</code></pre>
<p>Path of example:</p>
<pre><code>exercises/c_functions/broken_swap.c
</code></pre>
<p>Compiler/Linker commands:</p>
<pre><code>aarch64-none-elf-gcc -O1 -ffreestanding -nostdinc -nostdlib -nostartfiles -I../include/ \
-c broken_swap.c -o broken_swap.o
aarch64-none-elf-ld -nostdlib -nostartfiles start.o broken_swap.o ../common/uart.o -T link.ld -o broken_swap.elf
</code></pre>
<p>Use this command to run ELF file using QEMU:</p>
<p><code>qemu-system-aarch64 -M raspi3 -kernel broken_swap.elf -serial null -serial stdio -nographic</code></p>
<p>This output from this example produces following output:</p>
<pre><code>2
5
2
5
</code></pre>
<p>instead of the expected output of:</p>
<pre><code>2
5
5
2
</code></pre>
<p>Let us now look at the disassembly of the ELF file in order to understand why it is not generating the expected output.</p>
<p>Disassembly command:</p>
<pre><code>aarch64-none-elf-objdump --source -d broken_swap.elf &gt; broken_swap.disass
</code></pre>
<p>Disassembly output for swap function:</p>
<pre><code>0000000000080058 &lt;swap&gt;:
// function to swap the two numbers
void swap(int num1,int *num2)
{
    int temp;
    temp   = num1;
    num1   = num2;
    num2   =  temp;
}
   80058:	d65f03c0 	ret

</code></pre>
<p>Surprisingly, the compiler has just generated a <em>RET</em> for the <strong>swap</strong> function ignoring the C code to swap the two variables using of temporary variable!!!. This is because, when we call a function in C, only the values of the arguments are passed to the function. So, in the above code, values in variable <strong>NUM1</strong> and <strong>NUM2</strong> are copied to variables <strong>num1</strong> and <strong>num2</strong> of swap function. So, the changes to <em>num1</em> and <em>num2</em> get reflected only within the particular function. The compiler figures out that the modifications it performs to <strong>num1</strong> and <strong>num2</strong> variables in <strong>swap</strong> functions do not get used anywhere and therefore, chooses to optimize out the C statements within the <em>swap</em> function. </p>
<p>Let us know see how we can make modifications to function arguments to be seen by the calling function. To achieve this, we need to pass the address of the variable while calling the function. The following code shows the correct approach of performing the swapping so that the caller can see the effect.</p>
<p>Code for Swap function with ponters: </p>
<pre><code class="language-c">#include &quot;uart.h&quot;

// function to swap the two numbers
void swap(int *num1_ptr,int *num2_ptr)
{
    int temp;
    temp   = *num1_ptr;
    *num1_ptr   = *num2_ptr;
    *num2_ptr   =  temp;
}

int main()
{
    int num1 =  2, num2 = 5;

    //displaying numbers after swapping
    uart_print_num(num1);
    uart_print_num(num2);

    // Your code starts here

    swap(&amp;num1,&amp;num2);

    // Your code ends here

    //displaying numbers after swapping
    uart_print_num(num1);
    uart_print_num(num2);

    return 0;
}

</code></pre>
<p>Path of example:</p>
<pre><code>exercises/c_functions/swap_with_pointers.c
</code></pre>
<p>Compiler/Linker commands:</p>
<pre><code>aarch64-none-elf-gcc -O1 -ffreestanding -nostdinc -nostdlib -nostartfiles -I../include/ \
-c swap_with_pointers.c -o swap_with_pointers.o
aarch64-none-elf-ld -nostdlib -nostartfiles start.o swap_with_pointers.o ../common/uart.o -T link.ld -o swap_with_pointers.elf
</code></pre>
<p>Let us now look at its disassembly output for the swap function:</p>
<p>Disassembly command:</p>
<pre><code>aarch64-none-elf-objdump --source -d swap_with_pointers.elf &gt; swap_with_pointers.disass
</code></pre>
<p>Disassembly output for swap function:</p>
<pre><code>// function to swap the two numbers
void swap(int *num1_ptr,int *num2_ptr)
{
    int temp;
    temp   = *num1_ptr;
   80058:	b9400002 	ldr	w2, [x0]
    *num1_ptr   = *num2_ptr;
   8005c:	b9400023 	ldr	w3, [x1]
   80060:	b9000003 	str	w3, [x0]
    *num2_ptr   =  temp;
   80064:	b9000022 	str	w2, [x1]
}
   80068:	d65f03c0 	ret

</code></pre>
<p>The above code passes addresses of variables num1 and num1 to the swap() function. The <strong>swap</strong> function takes 2 pointer variables *num1_ptr and *num2_ptr. Pointer variable num1_ptr holds the address of num1 and pointer variable num2_ptr holds the address of variable num2. Let us now run this ELF file on QEMU using command:</p>
<p><code>qemu-system-aarch64 -M raspi3 -kernel broken_swap.elf -serial null -serial stdio -nographic</code></p>
<p>This code now produces the expected output:</p>
<pre><code>2
5
5
2
</code></pre>
<p>Since we are directly changing the value present at particular address, the value gets reflected in the calling function. Therefore the expected output gets printed.</p>
<h2 id="what-we-learned-5"><a class="header" href="#what-we-learned-5">What we learned</a></h2>
<ul>
<li>How to examine the disassembly output of ELF executable files</li>
<li>Analysis of disassembly output of common C language constructs</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h1>
<p>This concludes part one of the journey to learning ARM architecture and C programming. So far we have encountered the basics of AArch64 assembly language and the C programming language. We have learnt how C programs can be compiled to assembly code and and how a compiled binary can be disassembled back into assembly. We covered several user level AArch64 assembly instructions and some portion of the C programming syntax. </p>
<p>However, what we have learnt is only the begining. In part 2 and beyond we will learn more AArch64 assembly and architecture - including exception levels, virtual memory, multi-processing, coherence etc. - and explore using those features using assembly and C programs.</p>
<div style="break-before: page; page-break-before: always;"></div><ol>
<li>
<p><a href="https://developer.arm.com/documentation/ddi0487/ga/?lang=en">Arm Architecture Reference Manual Armv8, for Armv8-A architecture profile</a></p>
</li>
<li>
<p><a href="https://developer.arm.com/documentation/den0024/a">ARM Cortex-A Series Programmer's Guide for ARMv8-A</a></p>
</li>
<li>
<p><a href="https://developer.arm.com/documentation/ihi0036/d">Application Binary Interface for the Arm Architecture - The Base Standard</a></p>
</li>
<li>
<p><a href="https://github.com/ARM-software/abi-aa/releases">Procedure Call Standard for the Arm 64-bit Architecture</a></p>
</li>
<li>
<p><a href="https://developer.arm.com/documentation/ddi0596/2021-09">Arm A64 Instruction Set Architecture</a></p>
</li>
<li>
<p><a href="https://developer.arm.com/documentation/100748/0617/Assembling-Assembly-Code">Arm Compiler for Embedded User Guide Version 6.17</a></p>
</li>
<li>
<p><a href="https://developer.arm.com/architectures/system-architectures/software-standards/abi">Application Binary Interface</a></p>
</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            var socket = new WebSocket("ws://localhost:3000/__livereload");
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
